%{
/* -*- C++ -*-
   Copyright 2006 Christoph Bonitz (christoph.bonitz@gmail.com)
             2007 Adrian Prantl
   see LICENSE in the root folder of this project
*/
using namespace std;
#include <iostream>  
#include <vector>
#include <string>
#include "PrologTerm.h"
#include "PrologCompTerm.h"
#include "PrologList.h"
#include "PrologAtom.h"
#include "PrologString.h"
#include "PrologInt.h"
#include "PrologVariable.h"

extern int   yylex();
extern char* yytext;
extern int   yylineno;
extern int   colno;
PrologTerm*  prote;

void yyerror(char *);

%}

/*Token declarations*/
%token <strValue> VARIABLE 
%token <strValue> ATOM 
%token <strValue> OPERATOR
%token <strValue> STRING
%token <intValue> INT 




/*data structure*/
%union {
	std::string* strValue;
	int intValue;
	PrologTerm* singleTerm;
	std::vector<PrologTerm*>* termList;
}



/*nonterminal types*/
%type <singleTerm> term
%type <singleTerm> infix_pair
%type <singleTerm> pterm
%type <termList>   terms
%type <singleTerm> comp_term
%type <singleTerm> plist


%%

/*grammar*/
pterm:
 comp_term {prote = $1; $$ = $1;}
 | comp_term '.' {prote = $1; $$ = $1;}
;
term:
 STRING       { $$ = new PrologString(*$1);  }
 | ATOM       { $$ = new PrologAtom(*$1);    }
 | VARIABLE   { $$ = new PrologVariable(*$1);}
 | comp_term  { $$ = $1;                     }
 | infix_pair { $$ = $1;                     }
 | plist      { $$ = $1;                     }
 | INT        { $$ = new PrologInt($1);      }
| '(' term ')'{ $$ = $2;                     } 
;

comp_term:
 ATOM '(' terms ')' {
	PrologCompTerm *t = new PrologCompTerm(*$1);
	vector<PrologTerm*>::iterator it;
	it = $3->begin();
	while(it != $3->end()) {
		t->addSubterm(*it);
		it++;
	}
	$$ = t;
	}
;

/*TODO: no operator precedence yet*/
infix_pair:
 term OPERATOR term {
	PrologInfixOperator *ifx = new PrologInfixOperator(*$2);
	ifx->addSubterm($1);
	ifx->addSubterm($3);
	$$ = ifx;
	}
;


terms:
 terms ',' term {$1->push_back($3); $$=$1;} 
 | term {$$ = new vector<PrologTerm*>();$$->push_back($1);}
;

plist:
 '[' terms ']' {
	PrologList *t = new PrologList();
	vector<PrologTerm*>::iterator it;
	it = $2->begin();
	while(it != $2->end()) {
		t->addElement(*it);
		it++;
	}
	$$ = t;
	} |
 '[' ']' {PrologList* t = new PrologList(); $$ = t;}
;


%%
void yyerror(char* msg) {
  std::cerr << std::string(msg) 
	    << " at line " << yylineno 
	    << ", col. " << colno << ", "
	    << "near token \"" << yytext << "\"" << std::endl;
  exit(1);
}



