%{
/*
Copyright 2006 Christoph Bonitz (christoph.bonitz@gmail.com)
see LICENSE in the root folder of this project
*/
using namespace std;
#include <iostream>  
#include <vector>
#include <string>
#include "PrologTerm.h"
#include "PrologCompTerm.h"
#include "PrologList.h"
#include "PrologAtom.h"
#include "PrologString.h"
#include "PrologInt.h"
#include "PrologVariable.h"

extern int yylex();
extern char* yytext;
extern int yylineno;
PrologTerm* prote;

  void yyerror(char *);
%}

/*Token declarations*/
%token <strValue> VARIABLE 
%token <strValue> ATOM 
%token <strValue> STRING
%token <intValue> INT 




/*data structure*/
%union {
	std::string* strValue;
	int intValue;
	PrologTerm* singleTerm;
	std::vector<PrologTerm*>* termList;
}



/*nonterminal types*/
%type <singleTerm> term
%type <singleTerm> pterm
%type <termList> terms
%type <singleTerm> comp_term
%type <singleTerm> plist


%%

/*grammar*/
pterm:
 comp_term {prote = $1; $$ = $1;}
 | comp_term '.' {prote = $1; $$ = $1;}
;
term:
 STRING {$$ = new PrologString(*$1);}
 | ATOM {$$ = new PrologAtom(*$1);}
 | VARIABLE {$$ = new PrologVariable(*$1);}
 | comp_term {$$ = $1;}
 | plist {$$ = $1;}
 | INT {$$ = new PrologInt($1);}
;

comp_term:
 ATOM '(' terms ')' {
	PrologCompTerm *t = new PrologCompTerm(*$1);
	vector<PrologTerm*>::iterator it;
	it = $3->begin();
	while(it != $3->end()) {
		t->addSubterm(*it);
		it++;
	}
	$$ = t;
	}
;

terms:
 terms ',' term {$1->push_back($3); $$=$1;} 
 | term {$$ = new vector<PrologTerm*>();$$->push_back($1);}
;

plist:
 '[' terms ']' {
	PrologList *t = new PrologList();
	vector<PrologTerm*>::iterator it;
	it = $2->begin();
	while(it != $2->end()) {
		t->addElement(*it);
		it++;
	}
	$$ = t;
	} |
 '[' ']' {PrologList* t = new PrologList(); $$ = t;}
;


%%
void yyerror(char* msg) {
  std::cerr << std::string(msg) << " at line " << yylineno << " near " << yytext << std::endl;
  exit(1);
}



