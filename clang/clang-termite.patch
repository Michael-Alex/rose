Index: clang.xcodeproj/project.pbxproj
===================================================================
--- clang.xcodeproj/project.pbxproj	(revision 57167)
+++ clang.xcodeproj/project.pbxproj	(working copy)
@@ -371,7 +371,7 @@
 		84AF36A00CB17A3B00C820A5 /* DeclObjC.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; name = DeclObjC.h; path = clang/AST/DeclObjC.h; sourceTree = "<group>"; };
 		84D9A8870C1A57E100AC7ABC /* AttributeList.cpp */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.cpp.cpp; name = AttributeList.cpp; path = lib/Parse/AttributeList.cpp; sourceTree = "<group>"; };
 		84D9A88B0C1A581300AC7ABC /* AttributeList.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; name = AttributeList.h; path = clang/Parse/AttributeList.h; sourceTree = "<group>"; };
-		8DD76F6C0486A84900D96B5E /* clang */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.executable"; includeInIndex = 0; path = clang; sourceTree = BUILT_PRODUCTS_DIR; };
+		8DD76F6C0486A84900D96B5E /* clang */ = {isa = PBXFileReference; includeInIndex = 0; lastKnownFileType = "compiled.mach-o.executable"; path = clang; sourceTree = BUILT_PRODUCTS_DIR; };
 		9030C1090E807A9300941490 /* RewriteBlocks.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = RewriteBlocks.cpp; path = Driver/RewriteBlocks.cpp; sourceTree = "<group>"; };
 		DE01DA480B12ADA300AC22CE /* PPCallbacks.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; path = PPCallbacks.h; sourceTree = "<group>"; };
 		DE06756B0C051CFE00EBBFD8 /* ParseExprCXX.cpp */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.cpp.cpp; name = ParseExprCXX.cpp; path = lib/Parse/ParseExprCXX.cpp; sourceTree = "<group>"; };
@@ -1084,7 +1084,6 @@
 		08FB7793FE84155DC02AAC07 /* Project object */ = {
 			isa = PBXProject;
 			buildConfigurationList = 1DEB923508733DC60010E9CD /* Build configuration list for PBXProject "clang" */;
-			compatibilityVersion = "Xcode 2.4";
 			hasScannedForEncodings = 1;
 			mainGroup = 08FB7794FE84155DC02AAC07 /* clang */;
 			projectDirPath = "";
Index: include/clang/AST/Stmt.h
===================================================================
--- include/clang/AST/Stmt.h	(revision 57167)
+++ include/clang/AST/Stmt.h	(working copy)
@@ -35,6 +35,7 @@
   class StringLiteral;
   class SwitchStmt;
   class PrinterHelper;
+  class QualType;
     
 /// Stmt - This represents one statement.
 ///
@@ -89,6 +90,24 @@
   void dumpAll() const;
   void dumpAll(SourceManager &SM) const;
 
+  /// termDump - This does a local dump of the specified AST fragment.  It dumps the
+  /// specified node and a few nodes underneath it, but not the whole subtree.
+  /// This is useful in a debugger.
+  void termDump() const;
+  void termDump(SourceManager &SM) const;
+
+  // FIXME do a TermiteHelper instead
+  static std::string termGetType(QualType T);
+  static std::string termGetClassDecl(QualType T);
+  static std::string termDumpDecl(SourceManager &SM, Decl *D);
+  static std::string termGetDeclarationModifier(Decl* VD);
+  static std::string termGetStorageModifier(Decl* VD);
+
+  /// termDumpAll - This does a dump of the specified AST fragment and
+  /// all subtrees.
+  void termDumpAll() const;
+  void termDumpAll(SourceManager &SM) const;
+
   /// dumpPretty/printPretty - These two methods do a "pretty print" of the AST
   /// back to its original source language syntax.
   void dumpPretty() const;
Index: Driver/clang.cpp
===================================================================
--- Driver/clang.cpp	(revision 57167)
+++ Driver/clang.cpp	(working copy)
@@ -73,6 +73,7 @@
   EmitHTML,                     // Translate input source into HTML.
   ASTPrint,                     // Parse ASTs and print them.
   ASTDump,                      // Parse ASTs and dump them.
+  ASTTermDump,                  // Parse ASTs and dump them in TERMITE format.
   ASTView,                      // Parse ASTs and view them in Graphviz.
   TestSerialization,            // Run experimental serialization code.
   ParsePrintCallbacks,          // Parse and print each callback.
@@ -106,6 +107,8 @@
                         "Build ASTs and then pretty-print them"),
              clEnumValN(ASTDump, "ast-dump",
                         "Build ASTs and then debug dump them"),
+			 clEnumValN(ASTTermDump, "emit-term",
+                        "Build ASTs and then export them in the TERMITE format"),
              clEnumValN(ASTView, "ast-view",
                         "Build ASTs and view them with GraphViz"),
              clEnumValN(TestSerialization, "test-pickling",
@@ -1044,6 +1047,9 @@
     case ASTDump:
       return CreateASTDumper();
       
+    case ASTTermDump:
+      return CreateASTTermDumper();
+      
     case ASTView:
       return CreateASTViewer();   
       
Index: Driver/ASTConsumers.cpp
===================================================================
--- Driver/ASTConsumers.cpp	(revision 57167)
+++ Driver/ASTConsumers.cpp	(working copy)
@@ -538,6 +538,165 @@
 ASTConsumer *clang::CreateASTViewer() { return new ASTViewer(); }
 
 //===----------------------------------------------------------------------===//
+/// ASTTermDumper - TERMITE dump of ASTs
+
+namespace {
+  class ASTTermDumper : public ASTConsumer, public DeclPrinter {
+    SourceManager *SM;
+    FILE* F;
+  public:
+    ASTTermDumper() : DeclPrinter() {}
+
+
+    void Initialize(ASTContext &Context) {
+      SM = &Context.getSourceManager();
+      F = stderr;
+      fprintf(F, "project([\n");
+      lastFile = "";
+      lastDecl = 0;
+    }
+
+    ~ASTTermDumper() {
+      lastDecl = 0;
+      fprintf(F, "], ");     closeDecl(); // global
+      fprintf(F, ", null,"); closeDecl(); // file
+      fprintf(F, "], ");     closeDecl(); // project
+      fprintf(F, ".\n");
+    }
+
+    virtual void HandleTopLevelDecl(Decl *D) {
+
+      lastDecl = D;
+      std::string fileName = SM->getSourceName(lastDecl->getLocation());
+
+      std::string close = "";
+      // Start a new file() ?
+      if (fileName != lastFile) {
+	if (lastFile != "") {
+	  fprintf(F, "], "); closeDecl(); // global
+	  fprintf(F, ", ");  closeDecl(); // file
+	  fprintf(F, ", ");
+	}
+	fprintf(F, "file(\n  global([\n    ");
+	lastFile = fileName;
+      } else {
+	fprintf(F, ", ");
+      }
+      
+      if (FunctionDecl *FD = dyn_cast<FunctionDecl>(D)) {
+	DumpFunctionDecl(FD);
+      } else if (TypedefDecl *TD = dyn_cast<TypedefDecl>(D)) {
+	fprintf(F, Stmt::termDumpDecl(*SM, TD).c_str());
+	fprintf(F, ", ");
+	fileInfo();
+      } else if (ScopedDecl *SD = dyn_cast<ScopedDecl>(D)) {
+        Out << "Read top-level variable decl: '" << SD->getName() << "'\n";
+      } else if (ObjCInterfaceDecl *OID = dyn_cast<ObjCInterfaceDecl>(D)) {
+        Out << "Read objc interface '" << OID->getName() << "'\n";
+      } else if (ObjCProtocolDecl *OPD = dyn_cast<ObjCProtocolDecl>(D)) {
+        Out << "Read objc protocol '" << OPD->getName() << "'\n";
+      } else if (ObjCCategoryDecl *OCD = dyn_cast<ObjCCategoryDecl>(D)) {
+        Out << "Read objc category '" << OCD->getName() << "'\n";
+      } else if (isa<ObjCForwardProtocolDecl>(D)) {
+        Out << "Read objc fwd protocol decl\n";
+      } else if (isa<ObjCClassDecl>(D)) {
+        Out << "Read objc fwd class decl\n";
+      } else if (isa<FileScopeAsmDecl>(D)) {
+        Out << "Read file scope asm decl\n";
+      } else if (ObjCMethodDecl* MD = dyn_cast<ObjCMethodDecl>(D)) {
+        Out << "Read objc method decl: '" << MD->getSelector().getName()
+            << "'\n";
+        if (MD->getBody()) {
+          // FIXME: convert dumper to use std::ostream?
+          MD->getBody()->dumpAll(*SM);
+          Out << '\n';
+        }
+      } else if (isa<ObjCImplementationDecl>(D)) {
+        Out << "Read objc implementation decl\n";
+      } else if (isa<ObjCCategoryImplDecl>(D)) {
+        Out << "Read objc category implementation decl\n";
+      } else {
+        assert(0 && "Unknown decl type!");
+      }      
+    }
+
+  private:
+    std::string lastFile;
+    Decl* lastDecl;
+
+    void closeDecl() {
+      fprintf(F, "default_annotation(null, analysis_result(null,null)), ");
+      fileInfo();
+    }
+
+    void fileInfo() {
+      if (lastDecl) {
+	fprintf(F, "file_info('%s', %d, %d))", 
+		SM->getSourceName(lastDecl->getLocation()),
+		SM->getLineNumber(lastDecl->getLocation()),
+		SM->getColumnNumber(lastDecl->getLocation()));
+      } else fprintf(F, "file_info(null, 0, 0))");
+    }
+
+
+    void DumpFunctionDecl(FunctionDecl *FD) {
+      fprintf(F, "function_declaration(");
+      fprintf(F, "function_parameter_list(");
+
+      // FIXME...
+
+      if (FD->isInline())
+	assert(0 && "FIXME inline ");
+
+      const FunctionType *AFT = FD->getType()->getAsFunctionType();
+      if (const FunctionTypeProto *FT = dyn_cast<FunctionTypeProto>(AFT)) {
+	for (unsigned i = 0, e = FD->getNumParams(); i != e; ++i) {
+	  Stmt::termDumpDecl(*SM, FD->getParamDecl(i));
+	}
+    
+	if (FT->isVariadic()) {
+	  fprintf(F, "ellipse_expr(");
+	  closeDecl();
+	}
+      }
+      closeDecl(); // parameter list
+      fprintf(F, ", ");
+  
+      if (FD->getBody()) {
+	fprintf(F, "function_definition(");
+	// FIXME: convert dumper to use std::ostream?
+	FD->getBody()->termDumpAll(*SM);
+	fprintf(F, ", "); closeDecl();
+	fprintf(F, ", ");
+      } else 
+	fprintf(F, "null");
+
+      fprintf(F, "function_declaration_annotation(");
+      fprintf(F, "function_type(%s",
+	      Stmt::termGetType(AFT->getResultType()).c_str());
+      if (const FunctionTypeProto *FT = dyn_cast<FunctionTypeProto>(AFT)) {
+	fprintf(F, ", %d,", FT->isVariadic());
+	fprintf(F, "[");
+	for (unsigned i = 0, e = FD->getNumParams(); i != e; ++i) {
+	  QualType T = FD->getParamDecl(i)->getType();
+	  fprintf(F, Stmt::termGetType(T).c_str());
+	  if (i+1 < e) fprintf(F, ", ");
+	}
+	fprintf(F, "]),");
+      } else fprintf(F, "0, []),");
+
+      fprintf(F, "%s, %s, analysis_result(null, null)),", 
+	      FD->getName(),
+	      Stmt::termGetDeclarationModifier(FD).c_str()); // decl. annot
+      fileInfo(); // declaration
+    }
+  };
+}
+
+ASTConsumer *clang::CreateASTTermDumper() { return new ASTTermDumper(); }
+
+
+//===----------------------------------------------------------------------===//
 // AST Serializer
 
 namespace {
@@ -653,6 +812,7 @@
   return new SingleFileSerializer(FName, Diags);
 }
 
+
 class LLVMCodeGenWriter : public ASTConsumer {
   llvm::OwningPtr<CodeGenerator> Gen;
   const std::string &InFile;
Index: Driver/ASTConsumers.h
===================================================================
--- Driver/ASTConsumers.h	(revision 57167)
+++ Driver/ASTConsumers.h	(working copy)
@@ -35,6 +35,8 @@
 
 ASTConsumer *CreateASTDumper();
 
+ASTConsumer *CreateASTTermDumper();
+
 ASTConsumer *CreateASTViewer();
 
 ASTConsumer *CreateCodeRewriterTest(const std::string& InFile,
Index: lib/AST/StmtTermDumper.cpp
===================================================================
--- lib/AST/StmtTermDumper.cpp	(revision 0)
+++ lib/AST/StmtTermDumper.cpp	(revision 0)
@@ -0,0 +1,939 @@
+//===--- StmtTermDumper.cpp - TermDumping implementation for Stmt ASTs ----===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file implements the Stmt::termDump/Stmt::print methods, which
+// termDump out the AST in a form that exposes type details and other
+// fields.
+//
+//===----------------------------------------------------------------------===//
+
+#include "clang/AST/StmtVisitor.h"
+#include "clang/AST/DeclObjC.h"
+#include "clang/Basic/SourceManager.h"
+#include "llvm/Support/Compiler.h"
+#include <cstdio>
+#include <sstream>
+using namespace clang;
+using namespace std;
+
+//===----------------------------------------------------------------------===//
+// StmtTermDumper Visitor
+//===----------------------------------------------------------------------===//
+
+namespace  {
+  typedef pair<string,string> StringPair;
+
+  class VISIBILITY_HIDDEN StmtTermDumper : public StmtVisitor<StmtTermDumper> {
+    SourceManager *SM;
+    FILE *F;
+    unsigned IndentLevel;
+    
+    /// MaxDepth - When doing a normal termDump (not termDumpAll) we
+    /// only want to termDump the first few levels of an AST.  This
+    /// keeps track of how many ast levels are left.
+    unsigned MaxDepth;
+#   define AR "analysis_result(null,null)"
+#   define DA " default_annotation(null, " AR "),"
+
+    
+  public:
+    StmtTermDumper(SourceManager *sm, FILE *f, unsigned maxDepth)
+      : SM(sm), F(f), IndentLevel(0-1), MaxDepth(maxDepth) {
+    }
+    
+    void TermDumpSubTree(Stmt *S) {
+      // Prune the recursion if not using termDump all.
+      if (MaxDepth == 0) return;
+      
+      ++IndentLevel;
+      if (S) {
+        if (DeclStmt* DS = dyn_cast<DeclStmt>(S))
+          VisitDeclStmt(DS);
+        else {
+          Visit(S);
+          
+          // Print out children.
+          Stmt::child_iterator CI = S->child_begin(), CE = S->child_end();
+	  for (; CI != CE; CI++) {
+	    if (*CI) {
+	      StringPair w = wrap(*CI, S);
+	      fprintf(F, "\n%s", w.first.c_str());
+ 
+	      TermDumpSubTree(*CI);
+	      fprintf(F, "%s,", w.second.c_str());
+	    }
+          }
+	  // Print annotations, if not already there
+	  switch(S->getStmtClass()) {
+	  case Stmt::DeclRefExprClass:
+	  case Stmt::DeclStmtClass:
+	  case Stmt::IntegerLiteralClass:
+	    break;
+	  case Stmt::UnaryOperatorClass: {
+	    UnaryOperator* op = dyn_cast<UnaryOperator>(S);
+	    fprintf(F, " unary_op_annotation(");
+	    fprintf(F, "%d, ", op->isPostfix());
+	    TermDumpType(op->getType());
+	    fprintf(F, ", %s, %s, %s),", "null" /*throw_kind*/, "null", AR);
+	    break;
+	  }
+	  case Stmt::BinaryOperatorClass:
+	  case Stmt::CompoundAssignOperatorClass:
+	    fprintf(F, " binary_op_annotation(");
+	    TermDumpType((dyn_cast<Expr>(S))->getType());
+	    fprintf(F, ", " AR "),");
+	    break;
+	  case Stmt::IfStmtClass: {
+	    // if_stmt - add an empty else branch
+	    Stmt::child_iterator Else = S->child_begin(); ++Else;
+	    if (Else != S->child_end() && *Else) {
+	      fprintf(F, "null, ");
+	    } 
+	  } //fallthrough
+	  default:
+	    fprintf(F, DA);
+	  }
+	  TermDumpSourceRange(S);
+          fprintf(F, ")");
+        }
+      } else {
+	assert(0);
+        Indent();
+        fprintf(F, "<<<NULL>>>");
+      }
+      --IndentLevel;
+    }
+    
+    void Indent() const {
+      for (int i = 0, e = IndentLevel; i < e; ++i)
+        fprintf(F, "  ");
+    }
+    
+    void TermDumpStmt(const Stmt *Node);
+    
+    void TermDumpExpr(const Expr *Node) {
+      TermDumpStmt(Node);
+    }
+
+    void TermDumpType(QualType T) {
+      fprintf(F, Stmt::termGetType(T).c_str());
+    }
+
+    void TermDumpSourceRange(const Stmt *Node);
+    string getFileInfo(const Stmt *Node);
+    string getFileInfo(const SourceLocation PhysLoc);
+    const string getDefaultAnnotation() const { return DA; }
+
+    void DumpFunctionDecl(FunctionDecl *FD);
+   
+    // Stmts.
+    void VisitStmt(Stmt *Node);
+    void VisitDeclStmt(DeclStmt *Node);
+    void VisitLabelStmt(LabelStmt *Node);
+    void VisitGotoStmt(GotoStmt *Node);
+    
+    // Exprs
+    void VisitExpr(Expr *Node);
+    void VisitDeclRefExpr(DeclRefExpr *Node);
+    void VisitPredefinedExpr(PredefinedExpr *Node);
+    void VisitCharacterLiteral(CharacterLiteral *Node);
+    void VisitIntegerLiteral(IntegerLiteral *Node);
+    void VisitFloatingLiteral(FloatingLiteral *Node);
+    void VisitStringLiteral(StringLiteral *Str);
+    void VisitUnaryOperator(UnaryOperator *Node);
+    void VisitSizeOfAlignOfTypeExpr(SizeOfAlignOfTypeExpr *Node);
+    void VisitMemberExpr(MemberExpr *Node);
+    void VisitExtVectorElementExpr(ExtVectorElementExpr *Node);
+    void VisitBinaryOperator(BinaryOperator *Node);
+    void VisitCompoundAssignOperator(CompoundAssignOperator *Node);
+    void VisitAddrLabelExpr(AddrLabelExpr *Node);
+    void VisitTypesCompatibleExpr(TypesCompatibleExpr *Node);
+
+    // C++
+    void VisitCXXCastExpr(CXXCastExpr *Node);
+    void VisitCXXBoolLiteralExpr(CXXBoolLiteralExpr *Node);
+
+    // ObjC
+    void VisitObjCEncodeExpr(ObjCEncodeExpr *Node);
+    void VisitObjCMessageExpr(ObjCMessageExpr* Node);
+    void VisitObjCSelectorExpr(ObjCSelectorExpr *Node);
+    void VisitObjCProtocolExpr(ObjCProtocolExpr *Node);
+    void VisitObjCPropertyRefExpr(ObjCPropertyRefExpr *Node);
+    void VisitObjCIvarRefExpr(ObjCIvarRefExpr *Node);
+
+  private:
+    StringPair wrap(Stmt* Child, Stmt* Parent);
+  };
+}
+
+//===----------------------------------------------------------------------===//
+//  Utilities
+//===----------------------------------------------------------------------===//
+
+void StmtTermDumper::TermDumpSourceRange(const Stmt *Node) {
+  fprintf(stderr, getFileInfo(Node).c_str());
+}
+
+string StmtTermDumper::getFileInfo(const Stmt *Node) {
+  // Can't translate locations if a SourceManager isn't available.
+  if (SM == 0) return "file_info(null, 0, 0)";
+  
+  SourceRange R = Node->getSourceRange();
+  SourceLocation PhysLoc = SM->getPhysicalLoc(R.getBegin());
+  return getFileInfo(PhysLoc);
+}
+
+string StmtTermDumper::getFileInfo(const SourceLocation PhysLoc) {
+  stringstream ss;
+  ss << " file_info('"
+     << SM->getSourceName(PhysLoc) << "', "
+     << SM->getLineNumber(PhysLoc) << ", "
+     << SM->getColumnNumber(PhysLoc) << ")";
+  return ss.str();
+}
+
+
+
+//===----------------------------------------------------------------------===//
+//  Stmt printing methods.
+//===----------------------------------------------------------------------===//
+
+void StmtTermDumper::TermDumpStmt(const Stmt *Node) {
+  const char* n;
+
+  switch (Node->getStmtClass()) {
+    // Normal Statements.
+  case Stmt::NullStmtClass: n = "null_expression"; break;
+  case Stmt::CompoundStmtClass: n = "basic_block"; break;
+  case Stmt::CaseStmtClass: n = "case_option_stmt"; break;
+  case Stmt::DefaultStmtClass: n = "default_option_stmt"; break;
+  case Stmt::LabelStmtClass: n = "label_statement"; break;
+  case Stmt::IfStmtClass: n = "if_stmt"; break;
+  case Stmt::SwitchStmtClass: n = "switch_statement"; break;
+  case Stmt::WhileStmtClass: n = "while_stmt"; break;
+  case Stmt::DoStmtClass: n = "do_while_stmt"; break;
+  case Stmt::ForStmtClass: n = "for_statement"; break;
+  case Stmt::GotoStmtClass: n = "goto_statement"; break;
+  case Stmt::IndirectGotoStmtClass: n = "indirect_goto_stmt"; break;
+  case Stmt::ContinueStmtClass: n = "continue_stmt"; break;
+  case Stmt::BreakStmtClass: n = "break_stmt"; break;
+  case Stmt::ReturnStmtClass: n = "return_stmt"; break;
+  case Stmt::DeclStmtClass: n = "variable_declaration"; break;
+  case Stmt::SwitchCaseClass: n = "FIXME???switch_case_stmt"; break;
+
+    // GNU Stmt Extensions
+  case Stmt::AsmStmtClass: n = "asm_statement"; break;
+
+    // Obj-C statements
+  case Stmt::ObjCAtTryStmtClass: n = "objc_at_try_stmt"; break;
+  case Stmt::ObjCAtCatchStmtClass: n = "objc_at_catch_stmt"; break;
+  case Stmt::ObjCAtFinallyStmtClass: n = "objc_at_finally_stmt"; break;
+  case Stmt::ObjCAtThrowStmtClass: n = "objc_at_throw_stmt"; break;
+  case Stmt::ObjCAtSynchronizedStmtClass: 
+    n = "objc_at_synchronized_stmt"; break;
+    // Obj-C2 statements
+  case Stmt::ObjCForCollectionStmtClass: 
+    n = "objc_for_collection_stmt"; break;
+    // Expressions.
+  case Stmt::ExprClass: n = "expr_statement"; break;
+  case Stmt::PredefinedExprClass: n = "FIXME_predefined_expr"; break;
+  case Stmt::DeclRefExprClass: n = "var_ref_exp"; break;
+  case Stmt::IntegerLiteralClass: n = "int_val"; break;
+  case Stmt::FloatingLiteralClass: n = "double_val"; break;
+  case Stmt::ImaginaryLiteralClass: n = "imag_val"; break;
+  case Stmt::StringLiteralClass: n = "string_val"; break;
+  case Stmt::CharacterLiteralClass: n = "char_val"; break;
+  case Stmt::ParenExprClass: n = "clang_paren_expr"; 
+    n = "expr_statement"; break;
+  case Stmt::UnaryOperatorClass: n = "unary_op_exp"; break;
+  case Stmt::SizeOfAlignOfTypeExprClass: n = "size_of_exp"; break;
+  case Stmt::ArraySubscriptExprClass: n = "pntr_arr_ref_exp"; break;
+  case Stmt::CallExprClass: n = "function_call_exp"; break;
+  case Stmt::MemberExprClass: n = "dot_exp"; break;
+  case Stmt::CastExprClass: n = "cast_exp"; break;
+  case Stmt::BinaryOperatorClass: {
+    n = "binary_op_exp"; 
+    /* This one will be treated by VisitBinaryOperator() anyway */
+    return;
+  }
+  case Stmt::CompoundAssignOperatorClass: {
+    n = "clang_compound_assign_operator"; 
+    /* This one will be treated by VisitBinaryOperator() anyway */
+    return;
+  }
+  case Stmt::ConditionalOperatorClass: n = "conditional_exp"; break;
+  case Stmt::ImplicitCastExprClass: n = "cast_exp"; break;
+  case Stmt::ExplicitCastExprClass: n = "cast_exp"; break;
+  case Stmt::CompoundLiteralExprClass: 
+    n = "FIXME_compound_literal_exp initializer?"; break;
+  case Stmt::ExtVectorElementExprClass: 
+    n = "?ext_vector_element_exp"; break;
+  case Stmt::InitListExprClass: n = "initialized_name"; break;
+  case Stmt::VAArgExprClass: n = "ellipse_exp"; break;
+
+    // GNU Extensions.
+  case Stmt::AddrLabelExprClass: n = "gnu_addr_label_exp"; break;
+  case Stmt::StmtExprClass: n = "gnu_stmt_exp"; break;
+  case Stmt::TypesCompatibleExprClass: 
+    n = "gnu_types_compatible_expr_exp"; break;
+  case Stmt::ChooseExprClass: n = "gnu_choose_exp"; break;
+
+    // C++ Expressions.
+  case Stmt::CXXCastExprClass: n = "CXXcast_exp"; break;
+  case Stmt::CXXBoolLiteralExprClass: n = "bool_val"; break;
+  case Stmt::CXXThrowExprClass: n = "throw_exp"; break;
+  case Stmt::CXXDefaultArgExprClass: n = "default_arg_exp"; break;
+  case Stmt::CXXFunctionalCastExprClass: n = "FUNCcast_exp"; break;
+  case Stmt::CXXZeroInitValueExprClass: n = "zero_init_exp"; break;
+  case Stmt::CXXConditionDeclExprClass: n = "condition_decl_exp"; break;
+
+    // Obj-C Expressions.
+  case Stmt::ObjCStringLiteralClass: n = "objc_string_val"; break;
+  case Stmt::ObjCEncodeExprClass: n = "objc_encode_expr"; break;
+  case Stmt::ObjCMessageExprClass: n = "objc_message_expr"; break;
+  case Stmt::ObjCSelectorExprClass: n = "objc_selector_expr"; break;
+  case Stmt::ObjCProtocolExprClass: n = "objc_protocol_expr"; break;
+  case Stmt::ObjCIvarRefExprClass: n = "objc_var_ref_expr"; break;
+  case Stmt::ObjCPropertyRefExprClass: n = "objc_property_ref_expr"; break;
+
+    // Clang Extensions.
+  case Stmt::OverloadExprClass: n = "clang_overload_expr"; break;
+  case Stmt::ShuffleVectorExprClass: n = "clang_shuffle_vector_expr"; break;
+  case Stmt::BlockExprClass: n = "clang_block_expr"; break;
+  case Stmt::BlockDeclRefExprClass: n = "clang_block_decl_expr"; break;
+
+  default: n = "FIXME_stmt";
+  }
+
+  Indent();
+  fprintf(F, "%s(", n);
+}
+
+void StmtTermDumper::VisitStmt(Stmt *Node) {
+  TermDumpStmt(Node);
+}
+
+void StmtTermDumper::VisitDeclStmt(DeclStmt *Node) {
+  TermDumpStmt(Node);
+  fprintf(F,"\n");
+  for (ScopedDecl *D = Node->getDecl(); D; D = D->getNextDeclarator()) {
+    ++IndentLevel;
+    Indent();
+    fprintf(F, "%s", Stmt::termDumpDecl(*SM, D).c_str());
+    if (D->getNextDeclarator())
+      fprintf(F,"\n");
+    --IndentLevel;
+  }
+}
+
+void StmtTermDumper::VisitLabelStmt(LabelStmt *Node) {
+  TermDumpStmt(Node);
+  fprintf(F, " '%s'", Node->getName());
+}
+
+void StmtTermDumper::VisitGotoStmt(GotoStmt *Node) {
+  TermDumpStmt(Node);
+  fprintf(F, " '%s':%p", Node->getLabel()->getName(), (void*)Node->getLabel());
+}
+
+
+/// Translate between the structural differences of clang and ROSE:
+///   wraps, for example, the first child of for() into a
+///   for_init_statment node return the closing parenthesis characters
+StringPair StmtTermDumper::wrap(Stmt* Child, Stmt* Parent) {
+  stringstream open, close;
+
+  if (Child == 0) {
+    return StringPair(open.str(), close.str());
+  }
+
+  // for_statement
+  if (Parent->getStmtClass() == Stmt::ForStmtClass) {
+    Stmt::child_iterator init = Parent->child_begin();
+    Stmt::child_iterator test = init; ++test;
+    if (Child == *init) {
+      open << "for_init_statement([expr_statement(";
+      close << ", " << DA << getFileInfo(Child) 
+	    << ")], "<<DA << getFileInfo(Child) << ")";
+    } else if (Child == *test) {
+      open << "expr_statement(";
+      close << ", " << DA << getFileInfo(Child) << ")";
+    }
+  }
+
+  // Wrap expressions inside of a basic block into an expr_statement
+  if ((Parent->getStmtClass() == Stmt::CompoundStmtClass ||
+       Parent->getStmtClass() == Stmt::IfStmtClass) 
+      &&
+      (Child->getStmtClass() == Stmt::UnaryOperatorClass ||
+       Child->getStmtClass() == Stmt::BinaryOperatorClass ||
+       Child->getStmtClass() == Stmt::CompoundAssignOperatorClass
+       /*||
+       Child->getStmtClass() == Stmt::ExprClass ||
+       Child->getStmtClass() == Stmt::PredefinedExprClass ||
+       Child->getStmtClass() == Stmt::DeclRefExprClass ||
+       Child->getStmtClass() == Stmt::IntegerLiteralClass ||
+       Child->getStmtClass() == Stmt::FloatingLiteralClass ||
+       Child->getStmtClass() == Stmt::ImaginaryLiteralClass ||
+       Child->getStmtClass() == Stmt::StringLiteralClass ||
+       Child->getStmtClass() == Stmt::CharacterLiteralClass ||
+       Child->getStmtClass() == Stmt::ParenExprClass ||
+       Child->getStmtClass() == Stmt::UnaryOperatorClass ||
+       Child->getStmtClass() == Stmt::SizeOfAlignOfTypeExprClass ||
+       Child->getStmtClass() == Stmt::ArraySubscriptExprClass ||
+       Child->getStmtClass() == Stmt::CallExprClass ||
+       Child->getStmtClass() == Stmt::MemberExprClass ||
+       Child->getStmtClass() == Stmt::CastExprClass ||
+       Child->getStmtClass() == Stmt::BinaryOperatorClass ||
+       Child->getStmtClass() == Stmt::CompoundAssignOperatorClass ||
+       Child->getStmtClass() == Stmt::ConditionalOperatorClass ||
+       Child->getStmtClass() == Stmt::ImplicitCastExprClass ||
+       Child->getStmtClass() == Stmt::ExplicitCastExprClass ||
+       Child->getStmtClass() == Stmt::CompoundLiteralExprClass ||
+       Child->getStmtClass() == Stmt::ExtVectorElementExprClass ||
+       Child->getStmtClass() == Stmt::InitListExprClass ||
+       Child->getStmtClass() == Stmt::VAArgExprClass ||
+       Child->getStmtClass() == Stmt::AddrLabelExprClass || 
+       Child->getStmtClass() == Stmt::StmtExprClass ||
+       Child->getStmtClass() == Stmt::TypesCompatibleExprClass ||
+       Child->getStmtClass() == Stmt::ChooseExprClass ||
+       Child->getStmtClass() == Stmt::CXXCastExprClass ||
+       Child->getStmtClass() == Stmt::CXXBoolLiteralExprClass ||
+       Child->getStmtClass() == Stmt::CXXThrowExprClass ||
+       Child->getStmtClass() == Stmt::CXXDefaultArgExprClass ||
+       Child->getStmtClass() == Stmt::CXXFunctionalCastExprClass ||
+       Child->getStmtClass() == Stmt::CXXZeroInitValueExprClass ||
+       Child->getStmtClass() == Stmt::CXXConditionDeclExprClass*/)) {
+    open << "expr_statement(";
+    close << ", " DA << getFileInfo(Child) << ")";
+  }
+
+  // basic_block -> list
+  if (Parent->getStmtClass() == Stmt::CompoundStmtClass) {
+    Stmt::child_iterator CI = Parent->child_begin(), CE = Parent->child_end();
+    Stmt::child_iterator lastNonZero = CI;
+    // First
+    if (Child == *CI) {
+      string s = open.str();
+      open.str("");
+      open << "[" << s;
+    }
+
+    // Last
+    for (; CI != CE; CI++) {
+      if (*CI) lastNonZero = CI;
+    }
+    if (Child == *lastNonZero) 
+      close << "]";
+  }
+
+  return StringPair(open.str(), close.str());
+}
+
+//===----------------------------------------------------------------------===//
+//  Expr printing methods.
+//===----------------------------------------------------------------------===//
+
+void StmtTermDumper::VisitExpr(Expr *Node) {
+  TermDumpExpr(Node);
+}
+
+void StmtTermDumper::VisitDeclRefExpr(DeclRefExpr *Node) {
+  TermDumpExpr(Node);
+
+  fprintf(F, " ");
+  switch (Node->getDecl()->getKind()) {
+    case Decl::Function: fprintf(F,"FunctionDecl"); break;
+    case Decl::Var: 
+    case Decl::ParmVar: 
+      fprintf(F,"var_ref_exp_annotation(");
+      TermDumpType(Node->getType());
+      fprintf(F,", '%s', %s, %s, %s)", Node->getDecl()->getName(), 
+	      "0"/*static?*/, 
+	      "null"/*scope*/,
+	      AR); 
+      break;
+    case Decl::EnumConstant: fprintf(F,"EnumConstant"); break;
+    case Decl::Typedef: fprintf(F,"Typedef"); break;
+    case Decl::Struct: fprintf(F,"Struct"); break;
+    case Decl::Union: fprintf(F,"Union"); break;
+    case Decl::Class: fprintf(F,"Class"); break;
+    case Decl::Enum: fprintf(F,"Enum"); break;
+    case Decl::CXXStruct: fprintf(F,"CXXStruct"); break;
+    case Decl::CXXUnion: fprintf(F,"CXXUnion"); break;
+    case Decl::CXXClass: fprintf(F,"CXXClass"); break;
+    case Decl::ObjCInterface: fprintf(F,"ObjCInterface"); break;
+    case Decl::ObjCClass: fprintf(F,"ObjCClass"); break;
+    default: fprintf(F,"Decl"); break;
+  }
+  fprintf(F, ",");  
+  //fprintf(F, "='%s' %p", Node->getDecl()->getName(), (void*)Node->getDecl());
+}
+
+void StmtTermDumper::VisitObjCIvarRefExpr(ObjCIvarRefExpr *Node) {
+  TermDumpExpr(Node);
+
+  fprintf(F, " %sDecl='%s' %p", Node->getDecl()->getDeclKindName(), 
+                            Node->getDecl()->getName(), (void*)Node->getDecl());
+  if (Node->isFreeIvar())
+    fprintf(F, " isFreeIvar");
+}
+
+void StmtTermDumper::VisitPredefinedExpr(PredefinedExpr *Node) {
+  TermDumpExpr(Node);
+  switch (Node->getIdentType()) {
+  default: assert(0 && "unknown case");
+  case PredefinedExpr::Func:           fprintf(F, " __func__"); break;
+  case PredefinedExpr::Function:       fprintf(F, " __FUNCTION__"); break;
+  case PredefinedExpr::PrettyFunction: fprintf(F, " __PRETTY_FUNCTION__");break;
+  case PredefinedExpr::ObjCSuper:      fprintf(F, "super"); break;
+  }
+}
+
+void StmtTermDumper::VisitCharacterLiteral(CharacterLiteral *Node) {
+  TermDumpExpr(Node);
+  fprintf(F, " null, value_annotation('%c', " AR "),", 
+	  Node->getValue());
+}
+
+void StmtTermDumper::VisitIntegerLiteral(IntegerLiteral *Node) {
+  TermDumpExpr(Node);
+
+  bool isSigned = Node->getType()->isSignedIntegerType();
+  fprintf(F, " null, value_annotation(%s, " AR "),", 
+	  Node->getValue().toString(10, isSigned).c_str());
+}
+void StmtTermDumper::VisitFloatingLiteral(FloatingLiteral *Node) {
+  TermDumpExpr(Node);
+  fprintf(F, " null, value_annotation(%f, " AR "),", 
+	  Node->getValueAsApproximateDouble());
+}
+
+void StmtTermDumper::VisitStringLiteral(StringLiteral *Str) {
+  TermDumpExpr(Str);
+  // FIXME: this doesn't print wstrings right.
+  fprintf(F, " null, value_annotation('%s",
+	  Str->isWide() ? "L" : "");
+
+  for (unsigned i = 0, e = Str->getByteLength(); i != e; ++i) {
+    switch (char C = Str->getStrData()[i]) {
+    default:
+      if (isprint(C))
+        fputc(C, F); 
+      else
+        fprintf(F, "\\%03o", C);
+      break;
+    // Handle some common ones to make dumps prettier.
+    case '\\': fprintf(F, "\\\\"); break;
+    case '"':  fprintf(F, "\\\""); break;
+    case '\n': fprintf(F, "\\n"); break;
+    case '\t': fprintf(F, "\\t"); break;
+    case '\a': fprintf(F, "\\a"); break;
+    case '\b': fprintf(F, "\\b"); break;
+    }
+  }
+  fprintf(F, "', " AR "),");
+}
+
+void StmtTermDumper::VisitUnaryOperator(UnaryOperator *Node) {
+  const char* n;
+  switch (Node->getOpcode()) {
+  case UnaryOperator::PostInc:   n = "plus_plus_op";      break;
+  case UnaryOperator::PostDec:   n = "minus_minus_op";    break;
+  case UnaryOperator::PreInc:    n = "plus_plus_op";      break;
+  case UnaryOperator::PreDec:    n = "minus_minus_op";    break;
+  case UnaryOperator::AddrOf:    n = "address_of_op";     break;
+  case UnaryOperator::Deref:     n = "pointer_deref_exp"; break;
+  case UnaryOperator::Plus:      n = "plus_op";           break;
+  case UnaryOperator::Minus:     n = "minus_op";          break;  
+  case UnaryOperator::Not:       n = "bit_complement_op"; break;  
+  case UnaryOperator::LNot:      n = "not_op";            break;   
+  case UnaryOperator::SizeOf:    n = "size_of_op";        break;
+  case UnaryOperator::AlignOf:   n = "align_op";          break;  
+  case UnaryOperator::Real:      n = "real_op";           break;  
+  case UnaryOperator::Imag:      n = "imag_op";           break;     
+  case UnaryOperator::Extension: n = "extension_op";      break;  
+  case UnaryOperator::OffsetOf:  n = "offset_op";         break;  
+  }
+  Indent();
+  fprintf(F, "%s(", n);
+  //fprintf(F, " %s '%s'", Node->isPostfix() ? "postfix" : "prefix",
+  //        UnaryOperator::getOpcodeStr(Node->getOpcode()));
+}
+void StmtTermDumper::VisitSizeOfAlignOfTypeExpr(SizeOfAlignOfTypeExpr *Node) {
+  TermDumpExpr(Node);
+  fprintf(F, " %s ", Node->isSizeOf() ? "sizeof" : "alignof");
+  TermDumpType(Node->getArgumentType());
+}
+
+void StmtTermDumper::VisitMemberExpr(MemberExpr *Node) {
+  TermDumpExpr(Node);
+  fprintf(F, " %s%s %p", Node->isArrow() ? "->" : ".",
+          Node->getMemberDecl()->getName(), (void*)Node->getMemberDecl());
+}
+void StmtTermDumper::VisitExtVectorElementExpr(ExtVectorElementExpr *Node) {
+  TermDumpExpr(Node);
+  fprintf(F, " %s", Node->getAccessor().getName());
+}
+void StmtTermDumper::VisitBinaryOperator(BinaryOperator *Node) {
+  const char* n;
+  switch (Node->getOpcode()) {
+  case BinaryOperator::Mul:       n =         "multiply_op"; break;
+  case BinaryOperator::Div:       n =           "divide_op"; break; 
+  case BinaryOperator::Rem:       n =              "mod_op"; break;
+  case BinaryOperator::Add:       n =              "add_op"; break; 
+  case BinaryOperator::Sub:       n =         "subtract_op"; break;
+  case BinaryOperator::Shl:       n =           "lshift_op"; break;
+  case BinaryOperator::Shr:       n =           "rshift_op"; break;
+  case BinaryOperator::LT:        n =        "less_than_op"; break; 
+  case BinaryOperator::GT:        n =     "greater_than_op"; break;
+  case BinaryOperator::LE:        n =    "less_or_equal_op"; break;
+  case BinaryOperator::GE:        n = "greater_or_equal_op"; break; 
+  case BinaryOperator::EQ:        n =         "equality_op"; break;
+  case BinaryOperator::NE:        n =        "not_equal_op"; break;
+  case BinaryOperator::And:       n =          "bit_and_op"; break;
+  case BinaryOperator::Xor:       n =          "bit_xor_op"; break;
+  case BinaryOperator::Or:        n =           "bit_or_op"; break;
+  case BinaryOperator::LAnd:      n =              "and_op"; break;
+  case BinaryOperator::LOr:       n =               "or_op"; break;
+  case BinaryOperator::Assign:    n =           "assign_op"; break; 
+  case BinaryOperator::MulAssign: n =      "mult_assign_op"; break;
+  case BinaryOperator::DivAssign: n =       "div_assign_op"; break;
+  case BinaryOperator::RemAssign: n =       "mod_assign_op"; break;
+  case BinaryOperator::AddAssign: n =       "add_assign_op"; break;
+  case BinaryOperator::SubAssign: n =     "minus_assign_op"; break;
+  case BinaryOperator::ShlAssign: n =    "lshift_assign_op"; break;
+  case BinaryOperator::ShrAssign: n =    "rshift_assign_op"; break;
+  case BinaryOperator::AndAssign: n =       "and_assign_op"; break;
+  case BinaryOperator::XorAssign: n =       "xor_assign_op"; break;
+  case BinaryOperator::OrAssign:  n =        "or_assign_op"; break;
+  case BinaryOperator::Comma:     n =            "comma_op"; break;
+  default: n = "FIXME_op";
+  }
+  Indent();
+  fprintf(F, "%s(", n);
+  TermDumpExpr(Node);
+}
+void StmtTermDumper::VisitCompoundAssignOperator(CompoundAssignOperator *Node) {
+  VisitBinaryOperator(Node);
+}
+
+// GNU extensions.
+
+void StmtTermDumper::VisitAddrLabelExpr(AddrLabelExpr *Node) {
+  TermDumpExpr(Node);
+  fprintf(F, " %s %p", Node->getLabel()->getName(), (void*)Node->getLabel());
+}
+
+void StmtTermDumper::VisitTypesCompatibleExpr(TypesCompatibleExpr *Node) {
+  TermDumpExpr(Node);
+  fprintf(F, " ");
+  TermDumpType(Node->getArgType1());
+  fprintf(F, " ");
+  TermDumpType(Node->getArgType2());
+}
+
+//===----------------------------------------------------------------------===//
+// C++ Expressions
+//===----------------------------------------------------------------------===//
+
+void StmtTermDumper::VisitCXXCastExpr(CXXCastExpr *Node) {
+  TermDumpExpr(Node);
+  fprintf(F, " %s", CXXCastExpr::getOpcodeStr(Node->getOpcode()));
+}
+
+void StmtTermDumper::VisitCXXBoolLiteralExpr(CXXBoolLiteralExpr *Node) {
+  TermDumpExpr(Node);
+  fprintf(F, " %s", Node->getValue() ? "true" : "false");
+}
+
+//===----------------------------------------------------------------------===//
+// Obj-C Expressions
+//===----------------------------------------------------------------------===//
+
+void StmtTermDumper::VisitObjCMessageExpr(ObjCMessageExpr* Node) {
+  TermDumpExpr(Node);
+  fprintf(F, " selector=%s", Node->getSelector().getName().c_str());
+  IdentifierInfo* clsName = Node->getClassName();
+  if (clsName) fprintf(F, " class=%s", clsName->getName());
+}
+
+void StmtTermDumper::VisitObjCEncodeExpr(ObjCEncodeExpr *Node) {
+  TermDumpExpr(Node);
+ 
+  fprintf(F, " ");
+  TermDumpType(Node->getEncodedType());
+}
+
+void StmtTermDumper::VisitObjCSelectorExpr(ObjCSelectorExpr *Node) {
+  TermDumpExpr(Node);
+  
+  fprintf(F, " ");
+  Selector selector = Node->getSelector();
+  fprintf(F, "%s", selector.getName().c_str());
+}
+
+void StmtTermDumper::VisitObjCProtocolExpr(ObjCProtocolExpr *Node) {
+  TermDumpExpr(Node);
+  
+  fprintf(F, " ");
+  fprintf(F, "%s", Node->getProtocol()->getName());
+}
+
+void StmtTermDumper::VisitObjCPropertyRefExpr(ObjCPropertyRefExpr *Node) {
+  TermDumpExpr(Node);
+
+  if (Node->getKind() == ObjCPropertyRefExpr::MethodRef) {
+    ObjCMethodDecl *Getter = Node->getGetterMethod();
+    ObjCMethodDecl *Setter = Node->getSetterMethod();
+    fprintf(F, " Kind=MethodRef Getter=\"%s\" Setter=\"%s\"", 
+            Getter->getSelector().getName().c_str(),
+            Setter ? Setter->getSelector().getName().c_str() : "(null)");
+  } else {
+    fprintf(F, " Kind=PropertyRef Property=\"%s\"", Node->getProperty()->getName());
+  }
+}
+
+//===----------------------------------------------------------------------===//
+// Stmt method implementations
+//===----------------------------------------------------------------------===//
+
+/// termDump - This does a local dump of the specified AST fragment.
+/// It dumps the specified node and a few nodes underneath it, but not
+/// the whole subtree.  This is useful in a debugger.
+void Stmt::termDump(SourceManager &SM) const {
+  StmtTermDumper P(&SM, stderr, 4);
+  P.TermDumpSubTree(const_cast<Stmt*>(this));
+  fprintf(stderr, "\n");
+}
+
+/// termDump - This does a local termDump of the specified AST
+/// fragment.  It termDumps the specified node and a few nodes
+/// underneath it, but not the whole subtree.  This is useful in a
+/// debugger.
+void Stmt::termDump() const {
+  StmtTermDumper P(0, stderr, 4);
+  P.TermDumpSubTree(const_cast<Stmt*>(this));
+  fprintf(stderr, "\n");
+}
+
+/// termDumpAll - This does a termDump of the specified AST fragment
+/// and all subtrees.
+void Stmt::termDumpAll(SourceManager &SM) const {
+  StmtTermDumper P(&SM, stderr, ~0U);
+  P.TermDumpSubTree(const_cast<Stmt*>(this));
+  fprintf(stderr, "\n");
+}
+
+/// termDumpAll - This does a termDump of the specified AST fragment
+/// and all subtrees.
+void Stmt::termDumpAll() const {
+  StmtTermDumper P(0, stderr, ~0U);
+  P.TermDumpSubTree(const_cast<Stmt*>(this));
+  fprintf(stderr, "\n");
+}
+
+string Stmt::termGetClassDecl(QualType T) {
+  return "null";
+}
+
+/*
+enum class_type {
+  class = 0,
+  struct = 1,
+  union = 2,
+  template_parameter = 3
+  } 
+*/
+string Stmt::termGetType(QualType T) {
+  stringstream s;
+  if (PointerLikeType *PLT = dyn_cast<PointerLikeType>(T)) {
+    assert(0 && "Pointerlike Type");
+  } 
+  else if (VectorType *VT = dyn_cast<VectorType>(T)) {
+    assert(0 && "Vector Type");
+  } 
+  else if (ConstantArrayType *AT = dyn_cast<ConstantArrayType>(T)) {
+    s << "array_type(" << termGetType(AT->getElementType())
+      << AT->getSize().toString(10, false) << ")";
+  } 
+  else if (ArrayType *AT = dyn_cast<ArrayType>(T)) {
+    assert(0 && "Array Type");
+  } 
+  else if (RecordType *RT = dyn_cast<RecordType>(T)) {
+    s << "class_type("
+      << "'" << RT->getDecl()->getName() << "'," //RT.getAsString() 
+      << "1," 
+      << /*termGetScope(T)*/   "null),";
+  }
+  else if (EnumType *ET = dyn_cast<EnumType>(T)) {
+    assert(0 && "Enum Type");
+  }
+  else if (ComplexType *CT = dyn_cast<ComplexType>(T)) {
+    assert(0 && "Complex Type");
+  }
+  else if (TagType *TT = dyn_cast<TagType>(T)) {
+    assert(0 && "Tag Type");
+  }
+  else if (TypedefType *TDT = dyn_cast<TypedefType>(T)) {
+    QualType Simplified = TDT->LookThroughTypedefs();
+    s << "typedef_type(type_"
+      << Simplified.getAsString() << ", '" 
+      << TDT->getDecl()->getName() << "'),";
+  } 
+  else if (FunctionType *FT = dyn_cast<FunctionType>(T)) {
+    assert(0 && "Function Type");
+  }
+  else if (FunctionTypeProto *FT = dyn_cast<FunctionTypeProto>(T)) {
+    assert(0 && "Funciton Type Proto");
+  }
+  else if (ExtVectorType *VT = dyn_cast<ExtVectorType>(T)) {
+    assert(0 && "Ext. Vector Type");
+  }
+  else if (BuiltinType *TT = dyn_cast<BuiltinType>(T)) {
+    s << "type_" << T.getAsString();
+  }
+  else if (ObjCInterfaceType *TT = dyn_cast<ObjCInterfaceType>(T)) {
+    assert(0 && "ObjC Interface Type");
+  }
+  else if (ObjCQualifiedIdType *TT = dyn_cast<ObjCQualifiedIdType>(T)) {
+    assert(0 && "ObjC Qualified Type");
+  }
+  else if (ObjCQualifiedInterfaceType *TT = 
+	   dyn_cast<ObjCQualifiedInterfaceType>(T)) {
+    assert(0 && "ObjC Qualified Interface Type");
+  }
+  else assert(0 && "Unknown Type");
+  return s.str();
+}
+
+string Stmt::termDumpDecl(SourceManager &SM, Decl *D) {
+  stringstream annot;
+  FILE* F = stderr;
+  StmtTermDumper P(&SM, stderr, ~0U);
+  // FIXME: Need to complete/beautify this... this code simply shows the
+  // nodes are where they need to be.
+  if (TypedefDecl *TD = dyn_cast<TypedefDecl>(D)) {
+      string name = TD->getName();
+      string type = TD->getUnderlyingType().getAsString();
+      fprintf(stderr, "typedef_declaration(%s, "
+	      "typedef_annotation('%s', %s, 'typedef %s %s')", 
+	      "null", 
+	      name.c_str(), 
+	      termGetType(TD->getUnderlyingType()).c_str(),
+	      name.c_str(), type.c_str());
+  } else if (ValueDecl *VD = dyn_cast<ValueDecl>(D)) {
+
+    string namespace_definition = "null";
+    string fi = P.getFileInfo(VD->getLocation());
+
+    // If this is a vardecl with an initializer, emit it.
+    fprintf(F, "[initialized_name(");
+    if (VarDecl *V = dyn_cast<VarDecl>(VD)) {
+      Expr* init = V->getInit();
+      if (init) {
+	fprintf(F, "assign_initializer(");
+        P.TermDumpSubTree(init);
+	fprintf(F, ", assign_initializer_annotation(%s, %s),  %s)",
+		termGetType(init->getType()).c_str(), AR, 
+		P.getFileInfo(init).c_str());
+      } else fprintf(F, "null");
+    }
+
+    fprintf(F, ",");
+
+    stringstream ina;
+    ina << "initialized_name_annotation("
+      << termGetType(VD->getType()) << ", '" 
+      << VD->getName()              << "', "
+      << termGetStorageModifier(D)  << ", " 
+      << namespace_definition       << ", "
+      << AR "), " << fi << ")],";
+    fprintf(F, ina.str().c_str());
+	 
+    annot << "variable_declaration_specific("
+	  << termGetDeclarationModifier(D) << ", "
+	  << AR "), " << fi << ")";
+    
+  } else if (TagDecl *TD = dyn_cast<TagDecl>(D)) {
+    // print a free standing tag decl (e.g. "struct x;").
+    const char *tagname;
+    if (const IdentifierInfo *II = TD->getIdentifier())
+      tagname = II->getName();
+    else
+      tagname = "<anonymous>";
+    fprintf(F, "\"%s %s;\"", TD->getKindName(), tagname);
+    // FIXME: print tag bodies.
+  } else {
+    assert(0 && "Unexpected decl");
+  }
+
+  return annot.str();
+}
+
+
+string Stmt::termGetStorageModifier(Decl* VD) {
+  // Translate Storage classes
+  if (VarDecl *V = dyn_cast<VarDecl>(VD)) {
+    switch (V->getStorageClass()) {
+    case VarDecl::None:     return "0";
+    case VarDecl::Extern:   return "2"; 
+    case VarDecl::Static:   return "3";  
+    case VarDecl::Auto:     return "4"; 
+    case VarDecl::Register: return "6"; 
+    default: assert(0 && "Unknown storage class!");
+      return "0";
+      //unparse_storage_modifier(7) :- !, write('mutable ').
+      //unparse_storage_modifier(8) :- !, write('typedef ').
+      //unparse_storage_modifier(9) :- !, write('asm ').
+    }
+  }
+  if (FunctionDecl *F = dyn_cast<FunctionDecl>(F)) {
+    switch (F->getStorageClass()) {
+    case FunctionDecl::None:     return "0";
+    case FunctionDecl::Extern:   return "2"; 
+    case FunctionDecl::Static:   return "3"; 
+    case FunctionDecl::PrivateExtern:   return "2";  
+    default: assert(0 && "Unknown storage class!");
+      return "0";
+      //unparse_storage_modifier(7) :- !, write('mutable ').
+      //unparse_storage_modifier(8) :- !, write('typedef ').
+      //unparse_storage_modifier(9) :- !, write('asm ').
+    }
+  }
+  assert(0 && "Unknown decl type!");
+}
+
+// FIXME!!!
+string Stmt::termGetDeclarationModifier(Decl* VD) {
+  stringstream decl_mod;
+  /* e_unknown = 0, 
+     e_private = 1, 
+     e_protected = 2, 
+     e_public = 3, 
+     e_default = e_public, 
+     e_last_modifier */
+  string access_mod = "3";
+  string bit_vec = "[0,0,0,0,0,0,0,0]";
+  /*
+   * arg b: bit vector of SgTypeModifier
+   * arg u: enum of SgUPC_AccessModifier
+   * arg c: enum of SgConstVolatileModifier
+   * arg e: enum of SgElaboratedTypeModifier
+   */
+  string type_mod = 
+    "type_modifier([0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],1,1,1)";
+  
+  decl_mod << "declaration_modifier("
+    << bit_vec    << ", " 
+    << type_mod   << ", " 
+    << access_mod << ", " 
+    << termGetStorageModifier(VD) << ")";
+  return decl_mod.str();
+}
