Index: include/clang/AST/DeclBase.h
===================================================================
--- include/clang/AST/DeclBase.h	(revision 63505)
+++ include/clang/AST/DeclBase.h	(working copy)
@@ -197,7 +197,7 @@
   Decl(Kind DK, DeclContext *DC, SourceLocation L) 
     : Loc(L), NextDeclarator(0), NextDeclInScope(0), 
       DeclCtx(reinterpret_cast<uintptr_t>(DC)), DeclKind(DK), InvalidDecl(0),
-      HasAttrs(false), Implicit(false) {
+      HasAttrs(false), Implicit(false), Access(AS_none) {
     if (Decl::CollectingStats()) addDeclKind(DK);
   }
 
Index: include/clang/AST/ASTConsumer.h
===================================================================
--- include/clang/AST/ASTConsumer.h	(revision 63505)
+++ include/clang/AST/ASTConsumer.h	(working copy)
@@ -20,7 +20,7 @@
   class Decl;
   class TagDecl;
   class HandleTagDeclDefinition;
-  
+
 /// ASTConsumer - This is an abstract interface that should be implemented by
 /// clients that read ASTs.  This abstraction layer allows the client to be
 /// independent of the AST producer (e.g. parser vs AST dump file reader, etc).
@@ -53,8 +53,15 @@
   /// PrintStats - If desired, print any statistics.
   virtual void PrintStats() {
   }
-};
 
+  /// This is a quick hack added to support prolog and epilog generation for consumers
+  /// that produce a whole-program representation
+  virtual void OnFirstFile(const char*) { }; //called by the driver for the very first file
+  virtual void OnNewFile(const char*)   { }; //called by the driver for every file but the very first one
+  virtual void OnLastFile()  { };            //called by the driver for the very last file
+
+};  
+  
 } // end namespace clang.
 
 #endif
Index: include/clang/AST/Expr.h
===================================================================
--- include/clang/AST/Expr.h	(revision 63505)
+++ include/clang/AST/Expr.h	(working copy)
@@ -1750,12 +1750,18 @@
   virtual child_iterator child_end();
   
   typedef std::vector<Stmt *>::iterator iterator;
+  typedef std::vector<Stmt *>::const_iterator const_iterator;
   typedef std::vector<Stmt *>::reverse_iterator reverse_iterator;
+  typedef std::vector<Stmt *>::const_reverse_iterator const_reverse_iterator;
   
   iterator begin() { return InitExprs.begin(); }
+  const_iterator begin() const { return InitExprs.begin(); }
   iterator end() { return InitExprs.end(); }
+  const_iterator end() const { return InitExprs.end(); }
   reverse_iterator rbegin() { return InitExprs.rbegin(); }
+  const_reverse_iterator rbegin() const { return InitExprs.rbegin(); }
   reverse_iterator rend() { return InitExprs.rend(); }
+  const_reverse_iterator rend() const { return InitExprs.rend(); }
   
   // Serailization.
   virtual void EmitImpl(llvm::Serializer& S) const;
Index: include/clang/Lex/PPCallbacks.h
===================================================================
--- include/clang/Lex/PPCallbacks.h	(revision 63505)
+++ include/clang/Lex/PPCallbacks.h	(working copy)
@@ -53,6 +53,12 @@
   virtual void PragmaComment(SourceLocation Loc, const IdentifierInfo *Kind, 
                              const std::string &Str) {
   }
+
+  /// IncludeDirective - This callback is invoked when a #include directive
+  /// is read.
+  ///
+  virtual void IncludeDirective(SourceLocation Loc, const std::string &file) {
+  }
   
 };
 
Index: Driver/clang.cpp
===================================================================
--- Driver/clang.cpp	(revision 63505)
+++ Driver/clang.cpp	(working copy)
@@ -83,6 +83,7 @@
   EmitHTML,                     // Translate input source into HTML.
   ASTPrint,                     // Parse ASTs and print them.
   ASTDump,                      // Parse ASTs and dump them.
+  ASTTermDump,                  // Parse ASTs and dump them in TERMITE format.
   ASTView,                      // Parse ASTs and view them in Graphviz.
   PrintDeclContext,             // Print DeclContext and their Decls.
   TestSerialization,            // Run experimental serialization code.
@@ -124,6 +125,8 @@
                         "Build ASTs and then pretty-print them"),
              clEnumValN(ASTDump, "ast-dump",
                         "Build ASTs and then debug dump them"),
+			 clEnumValN(ASTTermDump, "emit-term",
+                        "Build ASTs and then export them in the TERMITE format"),
              clEnumValN(ASTView, "ast-view",
                         "Build ASTs and view them with GraphViz"),
              clEnumValN(PrintDeclContext, "print-decl-contexts",
@@ -490,12 +493,12 @@
                        llvm::cl::desc("Disallow implicit conversions between "
                                       "vectors with a different number of "
                                       "elements or different element types"));
+
 static llvm::cl::opt<bool>
-EnableBlocks("fblocks", llvm::cl::desc("enable the 'blocks' language feature"), llvm::cl::ValueDisallowed);
+EnableBlocks("fblocks", llvm::cl::desc("enable the 'blocks' language feature"),
+             llvm::cl::ValueDisallowed, llvm::cl::AllowInverse,
+             llvm::cl::ZeroOrMore);
 
-static llvm::cl::inverse_opt
-DisableBlocks("fno-blocks", llvm::cl::opposite_of(EnableBlocks), llvm::cl::ValueDisallowed);
-
 static llvm::cl::opt<bool>
 ObjCNonFragileABI("fobjc-nonfragile-abi", llvm::cl::desc("enable objective-c's nonfragile abi"));
 
@@ -623,7 +626,7 @@
   if (NoLaxVectorConversions.getPosition())
       Options.LaxVectorConversions = 0;
   Options.Exceptions = Exceptions;
-  if (EnableBlocks.getPosition() || DisableBlocks.getPosition())
+  if (EnableBlocks.getPosition())
     Options.Blocks = EnableBlocks;
 
   // Override the default runtime if the user requested it.
@@ -1272,6 +1275,9 @@
     case ASTDump:
       return CreateASTDumper();
       
+    case ASTTermDump:
+      return CreateASTTermDumper(InFile, OutputFile, PP);
+      
     case ASTView:
       return CreateASTViewer();   
 
@@ -1329,7 +1335,8 @@
 /// ProcessInputFile - Process a single input file with the specified state.
 ///
 static void ProcessInputFile(Preprocessor &PP, PreprocessorFactory &PPF,
-                             const std::string &InFile, ProgActions PA) {
+                             const std::string &InFile, ProgActions PA,
+                             bool IsFirstFile, bool IsLastFile) {
   llvm::OwningPtr<ASTConsumer> Consumer;
   bool ClearSourceMgr = false;
   
@@ -1433,7 +1440,17 @@
                                            /* FreeMemory = */ false);
       TU = new TranslationUnit(*Context);
     }
+
+    //this allows to dump prolog and epilog for a whole program representation
+    if(IsFirstFile)
+      Consumer->OnFirstFile(InFile.c_str());    
+    else
+      Consumer->OnNewFile(InFile.c_str());
+    
     ParseAST(PP, Consumer.get(), TU, Stats);
+
+    if(IsLastFile)
+      Consumer->OnLastFile();
   }
 
   if (VerifyDiagnostics)
@@ -1629,7 +1646,7 @@
         Diags.setClient(TextDiagClient);
 
       // Process the source file.
-      ProcessInputFile(*PP, PPFactory, InFile, PCH ? GeneratePCH : ProgAction);
+      ProcessInputFile(*PP, PPFactory, InFile, PCH ? GeneratePCH : ProgAction, i == 0, i == e - 1);
       
       HeaderInfo.ClearFileInfo();      
     }
Index: Driver/TermDumper.cpp
===================================================================
--- Driver/TermDumper.cpp	(revision 0)
+++ Driver/TermDumper.cpp	(revision 0)
@@ -0,0 +1,2265 @@
+//===--- StmtTermDumper.cpp - TermDumping implementation for Stmt ASTs ----===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file implements a pass to emit clang's internal AST into an external
+// file using the Termite representation of SATIrE.
+// 
+// See: http://www.complang.tuwien.ac.at/satire/
+//      http://www.complang.tuwien.ac.at/adrian/termite/
+//
+//===----------------------------------------------------------------------===//
+
+#include "clang.h"
+#include "clang/Lex/PPCallbacks.h"
+#include "clang/Lex/Preprocessor.h"
+#include "ASTConsumers.h"
+#include "clang/AST/ASTConsumer.h"
+#include "clang/AST/ASTContext.h"
+#include "clang/AST/StmtVisitor.h"
+#include "clang/AST/DeclObjC.h"
+#include "clang/AST/DeclCXX.h"
+#include "clang/Basic/SourceManager.h"
+#include "clang/Basic/FileManager.h"
+#include "llvm/Support/Compiler.h"
+#include <cstdio>
+#include <iostream>
+#include <iomanip>
+#include <fstream>
+#include <sstream>
+#include <queue>
+#include <string>
+#include <memory>
+
+
+using namespace clang;
+
+#define PPI "preprocessing_info(null)"
+#define AIB "analysis_info([])"
+//#define AI "analysis_info(null,null)"
+#define DA "default_annotation(null, " PPI "), " AIB
+#define DAB "default_annotation(null, " PPI "), " AIB
+
+//===----------------------------------------------------------------------===//
+/// ASTTermDumper - TERMITE dump of ASTs
+
+namespace {
+  class AtomSetStream {
+    std::ostream &O;
+    const char *Def;
+    bool isFirst;
+
+  public:
+    AtomSetStream(std::ostream &o, const char *def = "")
+      : O(o), Def(def), isFirst(true) {
+    }
+
+    std::ostream &operator <<(const std::string &s) {
+      if (!isFirst)
+        O << ", ";
+      else
+        O << "[";
+
+      O << s;
+
+      isFirst = false;
+
+      return O;
+    }
+
+    void close() {
+      if (isFirst)
+        O << "[" << Def;
+
+      O << "]";
+
+      isFirst = true;
+    }
+  };
+
+  class PPTracker : public PPCallbacks {
+
+  public:    
+    typedef enum {
+      ppd_include,
+      ppd_define
+    } pp_directive_t;
+   
+    typedef struct {
+      SourceLocation loc;
+      std::string code;
+      pp_directive_t type;
+    } PPDirective;
+
+  protected:
+    Preprocessor &PP;
+    SourceManager &SM;
+    
+    // a map of encountered preprocessor directives (per file)
+    std::map< FileID, std::queue<PPDirective> > PPDs;
+    
+  public:    
+    PPTracker(Preprocessor &pp) : PP(pp), SM(pp.getSourceManager()) { }
+
+    virtual void IncludeDirective(SourceLocation Loc, const std::string &file) {
+      if(!SM.isInSystemHeader(Loc)) {
+        PPDirective d;
+
+        d.loc = Loc;
+        d.code = std::string("#include ") + file;
+        d.type = ppd_include;
+        
+        assert(!Loc.isInvalid() && "expecting valid source location");
+        FileID fid = SM.getFileID(Loc);
+        PPDs[fid].push(d);
+      }
+    }
+
+    bool location_lt(SourceLocation l1, SourceLocation l2) {
+      assert(l1.isValid() && l2.isValid() && "expecting valid source locations");
+      PresumedLoc p1 = SM.getPresumedLoc(l1);
+      PresumedLoc p2 = SM.getPresumedLoc(l2);
+      
+      assert(strcmp(p1.getFilename(), p2.getFilename()) == 0
+             && "comparing locations for different files");
+      return p1.getLine() < p2.getLine() ||
+        (p1.getLine() == p2.getLine() && p1.getColumn() <= p2.getColumn());
+    }
+    
+    //dequeue directives declared _before_ loc
+    void dequeueDirectives(SourceLocation loc, std::list<PPDirective> &ppds) {
+      assert(!loc.isInvalid() && "expecting valid source location");
+      
+      FileID fid = SM.getFileID(loc);
+      std::queue<PPDirective> &Q = PPDs[fid];
+
+      while(!Q.empty()) {
+        PPDirective *d = &Q.front();
+        if(!location_lt(d->loc, loc))
+          break;
+        ppds.push_back(*d);
+        Q.pop();
+      }
+    }
+  };
+  
+  
+  class ASTTermDumper : public ASTConsumer {
+    /** reference to the source manager
+     */
+    SourceManager *SM;
+
+    /** name of the input source file.
+     */
+    const std::string &infile;
+
+    /** name of the output (term) file
+     */
+    const std::string &outfile;
+
+    /** output stream for term
+     */
+    std::ostream &Out;
+
+    /** true, if the next top-level declaration is the first in the
+        current compilation unit
+    */
+    bool first_decl;
+
+    /** name of the current source file
+     */
+    std::string current_source_file;
+
+    /** this is the current preprocessor object
+     */
+    Preprocessor *PP;
+
+    /** a preprocessor callback tracking #include and #define directives
+     */
+    PPTracker *tracker;
+    
+    /** return a outputstream for the given output-filename. If the name is "-"
+     *  std::cout is returned.
+     */
+    static std::ostream& getOutputStream(const std::string &outfilename) {
+      if (outfilename.empty())
+        return std::cout;
+      else
+        return *new std::ofstream(outfilename.c_str(), std::ofstream::app);
+    }
+  public:
+    ASTTermDumper(const std::string &infilename,
+                  const std::string &outfilename,
+                  Preprocessor *pp)
+      : infile(infilename), outfile(outfilename),
+        Out(getOutputStream(outfilename)), first_decl(true), PP(pp), tracker(NULL) {
+
+      //create and register a new PPTracker Object
+      assert(PP && "expecting a preprocessor object");
+      tracker = new PPTracker(*PP);
+
+      //configure the preprocessor
+      PP->setPPCallbacks(tracker);
+    }
+
+    ~ASTTermDumper() {
+      //semantically close the current file declaration
+      Out << "], "; closeDecl(Out); // global
+      Out << ", ";  closeDecl(Out); // file
+      
+      PP->setPPCallbacks(NULL);
+      
+      // free the output stream
+      if (&Out != &std::cout && &Out != &std::cerr) {
+        delete &Out;
+      }
+    }
+
+    void Initialize(ASTContext &Context) {
+      SM = &Context.getSourceManager();
+    }
+
+    void HandleNewFile(const std::string &fileName, bool first) {
+
+      //finish the declaration for the last file
+      if (!first) {
+        Out << ", ";
+      }
+
+      current_source_file = fileName;
+      
+      //start a new file 
+      Out << "file(\n  global([\n    ";
+    }
+    
+    //called by the driver for the very first file
+    virtual void OnFirstFile(const char* fileName) {
+      first_decl = true;      
+      Out << "project([\n";
+      HandleNewFile(fileName, true);
+    }
+
+    //called by the driver for every file but the very first one
+    virtual void OnNewFile(const char *fileName) {
+      first_decl = true;      
+      HandleNewFile(fileName, false);
+    }
+
+    //called by the driver for the very last file
+    virtual void OnLastFile() {
+      Out <<  "], " DAB ", ";
+      fileInfo(Out, current_source_file); // global
+      Out <<  "), null,"; closeDecl(Out); // file
+      Out <<  "], ";     closeDecl(Out); // project
+      Out <<  ".\n";
+    }
+    
+    virtual void HandleTopLevelDecl(Decl *D) {      
+      if(!first_decl)
+        Out << ", ";
+      termDecl(Out, D);
+      first_decl=false;        
+      if (D->getNextDeclarator())
+        HandleTopLevelDecl(D->getNextDeclarator());
+    }
+
+  private:
+    /***************************************************************************
+     * Helper                                                                  *
+     **************************************************************************/
+
+    void closeDecl(std::ostream &O) {
+      assert(current_source_file.length() > 0 && "no current source file");
+      O << DA ", "
+        << "file_info(" << quote(current_source_file) << ", 1, 1)"
+        << ")";      
+    }
+
+    void fileInfo(std::ostream &O, const SourceLocation Loc) {
+      SourceLocation L = SM->getInstantiationLoc(Loc);
+
+      if (L.isInvalid()) {
+        O << "file_info('NULL_FILE', 0, 0)";
+      }
+      else {
+        PresumedLoc PLoc = SM->getPresumedLoc(L);
+        assert(PLoc.isValid() && "encountered invalid presumed location");
+        O << "file_info('" << PLoc.getFilename() << "', " << PLoc.getLine()
+          << ", " << PLoc.getColumn() << ")";
+      }
+    }
+
+    void fileInfo(std::ostream &O, const Decl *D) {
+      if (!D) {
+        O << "file_info('NULL_FILE', 0, 0)";
+      }
+      else {
+        fileInfo(O, D->getLocation());
+      }
+    }
+
+    void fileInfo(std::ostream &O, const Stmt *S = NULL) {
+      if (!S) {
+        O << "file_info('NULL_FILE', 0, 0)";
+      }
+      else {
+        fileInfo(O, S->getSourceRange().getBegin());
+      }
+    }
+
+    void fileInfo(std::ostream &O, const std::string &file_name) {
+      assert(file_name.size() > 0 && "invalid file name");      
+      O << "file_info('" << file_name << "', 0, 0)";
+    }
+    
+    void preprocessingInfo(std::ostream &O) {
+      O << PPI;
+    }    
+
+    //dequeue and emit all the preprocessing info until loc
+    void preprocessingInfo(std::ostream &O, SourceLocation loc) {
+      std::list<PPTracker::PPDirective> L;
+      tracker->dequeueDirectives(loc, L);
+      preprocessingInfo(O, L);
+    }
+    
+    void preprocessingInfo(std::ostream &O, std::list<PPTracker::PPDirective> &L) {
+      bool first = true;
+      while(!L.empty()) {
+        PPTracker::PPDirective &d = L.front();
+        assert(d.type == PPTracker::ppd_include && "only #includes are implemented so far");
+        
+        if(first) {
+          O << "preprocessing_info([";
+          first = false;
+        }
+        else {
+          O << ", ";
+        }
+
+        O << "cpreprocessorIncludeDeclaration('"
+          << d.code << "\\n', before,";
+        fileInfo(O, d.loc);
+        O << ")";
+        
+        L.pop_front();
+      }
+
+      if(first)
+        O << PPI;
+      else
+        O << "])";
+    }
+    
+    std::string prologize(std::string s) {
+      std::string t;
+      std::string::iterator it;
+      it = s.begin();
+
+      // skip all leading '_'
+      while (*it == '_')
+        it++;
+
+      //lowercase first char (without prepending underscore)
+      if(it != s.end()) {
+        if(isUpper(*it)) {
+          t.push_back(toLower(*it));
+        } else {
+          t.push_back(*it);
+        }
+        it++;
+      }
+
+      //replace an uppercase letter with an underscore
+      //and its lowercase equivalent
+      while(it != s.end()) {
+        if(*it == ' ')
+          t.push_back('_');
+        else if(isUpper(*it)) {
+          t.push_back('_');
+          t.push_back(toLower(*it));
+        } else {
+          t.push_back(*it);
+        }
+        it++;
+      }
+      return t;
+    }
+
+    //the following three functions are borrowed from PrologTerm.h
+    static bool needs_quotes(const std::string s) {
+      if (s.length() == 0) 
+        return true;
+
+      bool alldigits = isdigit(s[0]);
+      for (std::string::const_iterator c = s.begin();
+           c != s.end(); ++c) {
+
+        if (alldigits) {
+          if (!isdigit(*c))
+            return true;
+          else continue;
+        }
+
+        if (!islower(*c) && !isupper(*c) && 
+            !(*c == '_'))
+          return true;
+      }
+      return false;
+    }
+
+    static bool is_reserved_operator(const std::string s) {
+      return s == "volatile";
+    }
+
+    static std::string quote(const std::string atom) {
+      std::string s;
+      if (atom.length() == 0) return "''";
+      if (((atom.length() > 0) && (!islower(atom[0])) && (!isdigit(atom[0])))
+          || needs_quotes(atom)) {
+        s = "'" + atom + "'";
+        return s;
+      } else if (is_reserved_operator(atom)) {
+        s = "(" + atom + ")";
+        return s;
+      }
+      return atom;
+    }
+
+    static std::string filter_string(std::string s) {
+      std::stringstream S;
+      for (unsigned int i = 0; i < s.length(); ++i) {
+        unsigned char c = s[i];
+        if(isalnum(c) || c == '_')
+          S << c;
+        else if (c == '.')
+          S << "_dot_";
+      }      
+      return S.str();
+    }
+    
+    static std::string escape_double(std::string s) {
+      std::string r;
+      for (unsigned int i = 0; i < s.length(); ++i) {
+        unsigned char c = s[i];
+        switch (c) {
+        case '\\': r += "\\\\"; break; // Literal backslash
+        case '\"': r += "\\\\\""; break; // Double quote
+        case '\'': r += "\\\\'"; break;  // Single quote
+        case '\n': r += "\\\\n"; break;  // Newline (line feed)
+        case '\r': r += "\\\\r"; break;  // Carriage return
+        case '\b': r += "\\\\b"; break;  // Backspace
+        case '\t': r += "\\\\t"; break;  // Horizontal tab
+        case '\f': r += "\\\\f"; break;  // Form feed
+        case '\a': r += "\\\\a"; break;  // Alert (bell)
+        case '\v': r += "\\\\v"; break;  // Vertical tab
+        default:
+          if (c < 32 || c > 127) {
+            std::stringstream strm;
+            strm << "\\\\" 
+                 << std::oct 
+                 << std::setfill('0') 
+                 << std::setw(3) 
+                 << (unsigned int)c // \nnn Character with octal value nnn
+                 << "\\\\"; // Prolog expects this weird syntax with a
+            // trailing backslash
+            r += strm.str();
+          } else {
+            r += c;
+          }
+        }
+      }
+      //cerr<<"escape_double("<<s<<") = "<< r <<endl;
+      return r;
+    }
+
+
+    static std::string escape(std::string s) {
+      std::string r;
+      for (unsigned int i = 0; i < s.length(); ++i) {
+        unsigned char c = s[i];
+        switch (c) {
+        case '\\': r += "\\\\"; break; // Literal backslash
+        case '\"': r += "\\\""; break; // Double quote
+        case '\'': r += "\\'"; break;  // Single quote
+        case '\n': r += "\\n"; break;  // Newline (line feed)
+        case '\r': r += "\\r"; break;  // Carriage return
+        case '\b': r += "\\b"; break;  // Backspace
+        case '\t': r += "\\t"; break;  // Horizontal tab
+        case '\f': r += "\\f"; break;  // Form feed
+        case '\a': r += "\\a"; break;  // Alert (bell)
+        case '\v': r += "\\v"; break;  // Vertical tab
+        default:
+          if (c < 32 || c > 127) {
+            std::stringstream strm;
+            strm << '\\' 
+                 << std::oct 
+                 << std::setfill('0') 
+                 << std::setw(3) 
+                 << (unsigned int)c // \nnn Character with octal value nnn
+                 << '\\'; // Prolog expects this weird syntax with a
+            // trailing backslash
+            r += strm.str();
+          } else {
+            r += c;
+          }
+        }
+      }
+      //cerr<<"escape("<<s<<") = "<< r <<endl;
+      return r;
+    }
+    
+    
+    /** get lower case of upper case letter */
+    char toLower(const char c) {
+      return (c - ('A'-'a'));
+    };
+
+    /** is a letter upper case? */
+    bool isUpper(const char c) {
+      return (('A' <= c) && ('Z' >= c));
+    }
+
+    /***************************************************************************
+     * Declarations                                                            *
+     **************************************************************************/
+
+    /** Print the termite representation of a some declaration.
+     */
+    void termDecl(std::ostream &O, const Decl *D);
+
+    void termTypedef(std::ostream &O, const Decl *D);
+    void termFunctionDecl(std::ostream &O, const Decl *D);
+    void termEnum(std::ostream &O, const Decl *D);
+    void termRecord(std::ostream &O, const Decl *D);
+    void termField(std::ostream &O, const Decl *D);
+
+    /***************************************************************************
+     * Types                                                                   *
+     **************************************************************************/
+
+    /** Print the termite representation of a type.
+     */
+    void termType(std::ostream &O, const QualType &T);
+
+    const Decl *getTypeDecl(const Type *T) const;
+    const QualType getQualType(const Decl *D) const;
+
+    /***************************************************************************
+     * Expression                                                              *
+     **************************************************************************/
+
+    /** print the termite representation of an expression.
+     */
+    void termStmt(std::ostream &O, const Stmt *S);
+    void termStmtWrapped(std::ostream &O, const Stmt *S);
+
+    void termUnaryOperator(std::ostream &O, const Stmt *S);
+    void termBinaryOperator(std::ostream &O, const Stmt *S);
+    void termDeclStmt(std::ostream &O, const Stmt *S);
+    void termCallExpr(std::ostream &O, const Stmt *S);
+    void termDeclRefExpr(std::ostream &O, const Stmt *S);
+    void termVarRefExpr(std::ostream &O, const Decl *D, const QualType &T,
+                        const Stmt *SL);
+
+    /***************************************************************************
+     * Misc                                                                    *
+     **************************************************************************/
+
+    /** Print an Identifier, if NULL print <anonymous>.
+     */
+    std::string declIdentifier(const Decl *D, const char* prefix="");
+
+    /** print the initialized name tag for a named variable
+     */
+    void termInitializedName(std::ostream &O, const Decl *D);
+
+    /** print an initializer
+     */
+    void termInitializer(std::ostream &O, const Stmt *S);
+
+    /** print if the declaration is static storage. queries variable and
+     *  function declarations, and assumes non static for all others.
+     */
+    void termStaticStorage(std::ostream &O, const Decl *D);
+
+    /** print access modifier information for a declaration
+     */
+    void termAccessModifier(std::ostream &O, const Decl *D);
+
+    /** print storage modifier information for a declaration
+     */
+    void termStorageModifier(std::ostream &O, const Decl *D);
+
+    /** print modifier information for a declaration
+     */
+    void termModifier(std::ostream &O, const Decl *D);
+
+    /** print modifier information for the type of a declaration
+     */
+    void termTypeModifier(std::ostream &O, const Decl *D);
+    void termTypeModifier(std::ostream &O, const QualType T);
+
+    /** print declaration attributes
+     */
+    void termDeclAttributes(std::ostream &O, const Decl *D);
+
+    /** print the context/scope of a declaration
+     */
+    void termDeclContext(std::ostream &O, const DeclContext *C);
+  };
+
+  void ASTTermDumper::termDecl(std::ostream &O, const Decl *D) {
+    switch (D->getKind()) {
+    case Decl::Typedef:
+      termTypedef(O, D);
+      break;
+
+    case Decl::Enum:
+      termEnum(O, D);
+      break;
+
+    case Decl::Record:
+      termRecord(O, D);
+      break;
+
+    case Decl::Function:
+      termFunctionDecl(O, D);
+      break;
+
+      // Variables/Parameters/Values ---------------
+    case Decl::EnumConstant:
+    case Decl::Var:
+    case Decl::OriginalParmVar: // original type for implicit promotes missing
+    case Decl::ImplicitParam:
+      O << "variable_declaration([";
+      termInitializedName(O, D);
+      O << "], variable_declaration_specific(";
+      termModifier(O, D);
+      O << ", ";
+      if(D->getKind() == Decl::Var)
+        preprocessingInfo(O, D->getLocation());
+      else
+        preprocessingInfo(O);
+      O << "), " AIB ", ";
+      fileInfo(O, D);
+      O << ")";
+      break;
+
+    case Decl::ParmVar: // TODO: ObjC-in/out + C++-default-value missing
+      termInitializedName(O, D);
+      break;
+
+    case Decl::Field:
+      termField(O, D);
+      break;
+
+    case Decl::LinkageSpec:
+
+      // C++/ObjC-C++ ---------------
+    case Decl::OverloadedFunction:
+    case Decl::ObjCIvar:
+    case Decl::ObjCAtDefsField:
+    case Decl::Namespace:
+    case Decl::CXXRecord:
+    case Decl::CXXMethod:
+    case Decl::CXXConstructor:
+    case Decl::CXXDestructor:
+    case Decl::CXXConversion:
+    case Decl::CXXClassVar: // is a VarDecl -- see termInitializedName
+    case Decl::NonTypeTemplateParm: // is a VarDecl -- see termInitializedName
+    case Decl::TemplateTypeParm: 
+    case Decl::ObjCMethod:
+      //         if (ObjCMethodDecl* MD = dyn_cast<ObjCMethodDecl>(D)) {
+      //           Out << "Read objc method decl: '" << MD->getSelector().getAsString()
+      //               << "'\n";
+      //           if (MD->getBody()) {
+      // //             FIXME: convert dumper to use std::ostream?
+      //             MD->getBody()->dumpAll(*SM);
+      //             Out << '\n';
+      //           }
+    case Decl::ObjCContainer:
+    case Decl::ObjCCategory:
+    case Decl::ObjCProtocol:
+    case Decl::ObjCInterface:
+    case Decl::ObjCCategoryImpl:
+    case Decl::ObjCProperty:
+    case Decl::ObjCCompatibleAlias:
+    case Decl::ObjCPropertyImpl:
+    case Decl::ObjCImplementation:
+    case Decl::ObjCForwardProtocol:
+    case Decl::ObjCClass:
+
+      // Misc ---------------
+    case Decl::TranslationUnit:
+    case Decl::FileScopeAsm:
+    case Decl::Block:
+    default:
+      O << "unknown_decl(" << D->getDeclKindName() << ")";
+    }
+  }
+
+  void ASTTermDumper::termTypedef(std::ostream &O, const Decl *D) {
+    const TypedefDecl *TD = cast<TypedefDecl>(D);
+
+    O << "typedef_declaration(";
+
+    const Decl* UD = getTypeDecl(TD->getUnderlyingType().getTypePtr());
+    if (UD)
+      termDecl(O, UD);
+    else
+      O << "null";
+    // TODO: check what to do here
+    //       termType(O, TD->getUnderlyingType());
+
+    O << ", typedef_annotation("
+      << declIdentifier(D)
+      << ", ";
+    
+    termType(O, TD->getUnderlyingType());
+    O << ", ";
+    if (UD)
+      termDecl(O, UD);
+    else
+      O << "null";
+    
+    O << ", ";
+    preprocessingInfo(O, TD->getLocation());
+    
+    O << "), " AIB ", ";
+    fileInfo(O, TD);
+    O << ")";    
+  }
+
+  void ASTTermDumper::termFunctionDecl(std::ostream &O, const Decl *D) {
+    const FunctionDecl *FD = cast<FunctionDecl>(D);
+
+    O << "function_declaration("
+      << "function_parameter_list([";
+
+    // TODO: Qualifier e.g. FD->isInline(), isVirtual, isPure, ...
+    //       Storage Class
+
+    // print parameter list
+    const FunctionType *AFT = FD->getType()->getAsFunctionType();
+    if (const FunctionTypeProto *FT = dyn_cast<FunctionTypeProto>(AFT)) {
+      bool first = true;
+      for (unsigned i = 0, e = FD->getNumParams(); i != e; ++i) {
+        if (!first)
+          O << ", ";
+
+        termDecl(O, FD->getParamDecl(i));
+        first = false;
+      }
+
+      if (FT->isVariadic()) {
+        // TODO: replace by ellipse_expr ?? - from Adrian's original patch
+        O << ",initialized_name(null, "
+          "initialized_name_annotation(type_ellipse, '', default, null), " AIB
+          ", ";
+        fileInfo(O, FD);
+        O << ")";
+      }
+    }
+    O << "], " DAB ", ";
+    fileInfo(O, FD); // close parameter list
+    O << ")";
+
+    //collect all preprocessor declarations _before_ handling the function body
+    std::list<PPTracker::PPDirective> PPD;
+    tracker->dequeueDirectives(FD->getLocation(), PPD);
+    
+    if (FD->getBody()) {
+      O << ", function_definition(";
+      termStmt(O, FD->getBody());
+      O << ", " DAB ", ";
+      fileInfo(O, FD);
+      O << "), ";
+    } else
+      O << ", null, ";
+
+    O << "function_declaration_annotation(";
+    // TODO: check if we should dump the complete function type here?
+    // Alternatively rename the tag to result_type?
+    termType(O, FD->getType());
+
+    O << ", "
+      << declIdentifier(FD)
+      << ", ";
+    
+    termModifier(O, D);
+    O << ", ";
+    preprocessingInfo(O, PPD);
+    O << "), " AIB ",";
+    fileInfo(Out, FD); // declaration
+    O << ")";
+  }
+
+  void ASTTermDumper::termEnum(std::ostream &O, const Decl *D) {
+    const EnumDecl *E = cast<EnumDecl>(D);
+
+    O << "enum_declaration([";
+
+    bool first = true;
+    for(EnumDecl::enumerator_iterator i = E->enumerator_begin(),
+          ie = E->enumerator_end(); i != ie; i++) {
+      if (!first)
+        O << ", ";
+      termInitializedName(O, *i);
+      first = false;
+    }
+
+    O << "], enum_declaration_annotation("
+      << declIdentifier(E)
+      << ", ";
+    
+    termDeclAttributes(O, D);
+    
+    O << ", 1"  // TODO: d->get_embedded() from rose??
+      "), " AIB ", ";
+
+    fileInfo(O, D);
+    O << ")";
+  }
+
+  void ASTTermDumper::termRecord(std::ostream &O, const Decl *D) {
+    const RecordDecl *R = cast<RecordDecl>(D);
+
+    O << "class_declaration(class_definition([";
+
+    // print fields
+    bool first = true;
+    for(RecordDecl::field_iterator i = R->field_begin(), ie = R->field_end();
+        i != ie; i++) {
+      if (!first)
+        O << ", ";
+
+      termField(O, *i);
+      first = false;
+    }
+    O << "], class_definition_annotation(";
+    fileInfo(O, D);
+    O << ", ";
+    preprocessingInfo(O);
+    O << ")";
+
+    O << ", " AIB ", ";
+    fileInfo(O, D);
+
+    O << "), class_declaration_annotation("
+      << declIdentifier(R)
+      << ", " << R->getKindName()
+      << ", class_type("
+      << declIdentifier(R)
+      << ", " << R->getKindName() << ", "
+      << "::),";
+    
+    preprocessingInfo(O, D->getLocation());
+    O << "), " AIB ", ";
+    fileInfo(O, D);
+    O << ")";
+    //preprocessingInfo(O);    
+  }
+
+  void ASTTermDumper::termField(std::ostream &O, const Decl *D) {
+
+    // TODO: isMutable, isBitField
+    // const FieldDecl *F = cast<FieldDecl>(D);
+
+    O << "variable_declaration([";
+    termInitializedName(O, D);
+    O << "], variable_declaration_specific(";
+    termModifier(O, D);
+
+    O << ", ";
+    preprocessingInfo(O);
+    
+    O << "), " AIB ", ";
+    fileInfo(O, D);
+    O << ")";
+  }
+
+  /***************************************************************************
+   * Types                                                                   *
+   **************************************************************************/
+
+  void ASTTermDumper::termType(std::ostream &O, const QualType &T) {
+    if (T.getCVRQualifiers()) {
+      O << "modifier_type(";
+    }
+
+    switch (T->getTypeClass()) {
+    case Type::Builtin:
+      O << "type_" << prologize(cast<BuiltinType>(T)->getName());
+      break;
+
+      // Pointer ------------
+    case Type::Pointer:
+      O << "pointer_type(";
+      termType(O, cast<PointerLikeType>(T)->getPointeeType());
+      O << ")";
+      break;
+
+      // Arrays ------------
+    case Type::ConstantArray: // fallthrough
+    case Type::VariableArray: // fallthrough
+    case Type::IncompleteArray: // fallthrough
+    case Type::DependentSizedArray:
+      {
+        ArrayType *AT = cast<ArrayType>(T);
+
+        O << "array_type(";
+        termType(O, AT->getElementType());
+
+        switch (T->getTypeClass()) {
+        case Type::ConstantArray:
+          O << ", unsigned_long_val(null,"
+            "value_annotation("
+            << cast<ConstantArrayType>(T)->getSize().toString(10, false) <<
+            ", " << PPI << 
+            "), " AIB ", file_info('<invalid>', '<invalid>', '<invalid>'))";
+          break;
+        case Type::VariableArray:
+          termStmt(O, cast<VariableArrayType>(T)->getSizeExpr());
+          break;
+        case Type::IncompleteArray:
+          break;
+        case Type::DependentSizedArray:
+          termStmt(O, cast<DependentSizedArrayType>(T)->getSizeExpr());
+          break;
+        default:
+          assert(false);
+        }
+
+        // TODO: check how to dump for ROSE
+        // switch (AT->getSizeModifier()) {
+        //   case ArrayType::Normal: O << ", Normal"; break;
+        //   case ArrayType::Static: O << ", Static"; break;
+        //   case ArrayType::Star:   O << ", Star"; break;
+        // }
+
+        // TODO: Don't know what this is exactly.
+        // O << ", " << AT->getIndexTypeQualifier();
+        O << ", null)";
+        break;
+      }
+
+      // Function ------------
+    case Type::FunctionNoProto:
+      O << "function_type(";
+      termType(O, cast<FunctionTypeNoProto>(T)->getResultType());
+      O << ", default, [])";
+      break;
+    case Type::FunctionProto:
+      {
+        // TODO: print qualifier
+        // << FT->getTypeQuals()
+
+        FunctionTypeProto *FT = cast<FunctionTypeProto>(T);
+        O << "function_type(";
+        termType(O, FT->getResultType());
+        O << ", " << (FT->isVariadic() ? "ellipses" : "default")
+          << ", [";
+
+        bool first = true;
+        for(FunctionTypeProto::arg_type_iterator i = FT->arg_type_begin(),
+              ie = FT->arg_type_end(); i != ie; i++) {
+          if (!first)
+            O << ", ";
+          termType(O, *i);
+          first = false;
+        }
+
+        if (FT->isVariadic()) {
+          if (!first)
+            O << ", ";
+
+          O << "type_ellipse";
+        }
+
+        O << "])";
+        break;
+      }
+
+      // TypeOf ------------
+    case Type::TypeOfExp:
+      O << "type_of_expr(";
+      termStmt(O, cast<TypeOfExpr>(T)->getUnderlyingExpr());
+      O << ")";
+      break;
+    case Type::TypeOfTyp:
+      O << "type_of_type(";
+      termType(O, cast<TypeOfType>(T)->getUnderlyingType());
+      O << ")";
+      break;
+
+      // Typedefs ------------
+    case Type::TypeName: {
+      TypedefType *TDT = cast<TypedefType>(T);
+      QualType Simplified = TDT->LookThroughTypedefs();
+      O << "typedef_type("
+        << declIdentifier(TDT->getDecl())
+        << ", ";
+      termType(O, Simplified);
+      O << ")";
+      break;
+    }
+
+      // Tagged ------------
+    case Type::Tagged:
+      if (RecordType *RT = dyn_cast<RecordType>(T)) {
+        O << "class_type("
+          << declIdentifier(RT->getDecl())
+          << ", " << RT->getDecl()->getKindName() << ", ";
+//         termDeclContext(O, RT->getDecl()->getDeclContext());
+        O << "::)";
+      }
+      else if (EnumType *ET = dyn_cast<EnumType>(T)) {
+        O << "enum_type(";
+        termDecl(O, ET->getDecl());
+        O << ")";
+      }
+      else assert(0 && "Unknown Tagged Type");
+      break;
+
+      // C-C++/ObjC-C++/Embedded-C ------------
+    case Type::Reference:
+    case Type::MemberPointer:
+    case Type::ASQual:
+    case Type::TemplateTypeParm:
+    case Type::ObjCInterface:
+    case Type::ObjCQualifiedInterface:
+    case Type::ObjCQualifiedId:
+
+      // Misc ------------
+    case Type::Vector:
+    case Type::ExtVector:
+    case Type::Complex:
+    case Type::BlockPointer:
+    default:
+      O << "some_type, ";
+    }
+
+    if (T.getCVRQualifiers()) {
+      O << ", ";
+      termTypeModifier(O, T);
+      O << ")";
+    }
+  }
+
+  const Decl *ASTTermDumper::getTypeDecl(const Type *T) const {
+    switch (T->getTypeClass()) {
+    case Type::Tagged: 
+      if (const RecordType *RT = dyn_cast<RecordType>(T)) {
+        return  RT->getDecl();
+      }
+      else if (const EnumType *ET = dyn_cast<EnumType>(T)) {
+        return ET->getDecl();
+      }
+      else assert(0 && "Unknown Tagged Type");
+    default:
+      return NULL;
+    }
+  }
+
+  const QualType ASTTermDumper::getQualType(const Decl *D) const {
+    QualType type(NULL, 0);
+
+    // Translate type modifier
+    if (const VarDecl *V = dyn_cast<VarDecl>(D)) {
+      type = V->getType();
+    }
+    else if (const EnumConstantDecl *E = dyn_cast<EnumConstantDecl>(D)) {
+      type = E->getType();
+    }
+    else if (const FunctionDecl *F = dyn_cast<FunctionDecl>(D)) {
+      type = F->getType();
+    }
+    else if (const FieldDecl *F = dyn_cast<FieldDecl>(D)) {
+      type = F->getType();
+    }
+    else
+      assert(0 && "Unknown decl type!");
+
+    return type;
+  }
+
+  /***************************************************************************
+   * Expression                                                              *
+   **************************************************************************/
+
+  void ASTTermDumper::termStmt(std::ostream &O, const Stmt *S) {
+    enum cast_kind_t {
+      ck_undef,
+      ck_implicit,
+      ck_c_style,
+      ck_const,
+      ck_static,
+      ck_dynamic,
+      ck_reinterpret
+    };
+    cast_kind_t castKind = ck_undef;
+
+    if(!S) {
+      O << "null_expression(" DAB ", ";
+      fileInfo(O, S);
+      O << ")";      
+    }
+    else {
+      
+      switch (S->getStmtClass()) {
+      case Stmt::NullStmtClass:
+        O << "null_expr";
+        break;
+
+      case Stmt::CompoundStmtClass:
+        {
+          const CompoundStmt *CS = cast<CompoundStmt>(S);
+          O << "basic_block([";
+
+          bool first = true;
+          for(CompoundStmt::const_body_iterator i = CS->body_begin(),
+                ie = CS->body_end(); i != ie; i++) {
+            if (!first)
+              O << ", ";
+
+            termStmtWrapped(O, *i);
+            first = false;
+          }
+
+          O << "], " DAB ", ";
+          fileInfo(O, S);
+          O << ")";
+          break;
+        }
+
+      case Stmt::SwitchCaseClass:
+        assert(false && "Should never be found.");
+        break;
+
+      case Stmt::CaseStmtClass:
+        {
+          const CaseStmt *CS = cast<CaseStmt>(S);
+
+          assert(!CS->getRHS() && "GNU extension for case not supported.\n");
+
+          O << "case_option_stmt(";
+          termStmt(O, CS->getLHS());
+          O << ", ";
+          termStmtWrapped(O, CS->getSubStmt());
+          // TODO: find what this is for.
+          O << ", null"
+            ", " DAB ", ";
+          fileInfo(O, CS);
+          O << ")";          
+          break;
+        }
+
+      case Stmt::DefaultStmtClass:
+        {
+          const DefaultStmt *DS = cast<DefaultStmt>(S);
+
+          O << "default_option_stmt(";
+          termStmtWrapped(O, DS->getSubStmt());
+          O << ", " DAB ", ";
+          fileInfo(O, DS);
+          O << ")";
+          break;
+        }
+
+      case Stmt::LabelStmtClass:
+        {
+          const LabelStmt *L = cast<LabelStmt>(S);
+          O << "label_statement(label_annotation("
+            << quote(L->getName()) << ", ";
+          preprocessingInfo(O);
+          O <<"), " AIB ", ";
+          fileInfo(O, S);
+          O << ")";
+
+          if (L->getSubStmt()->getStmtClass() != Stmt::NullStmtClass) {
+            O << ", ";
+            termStmt(O, L->getSubStmt());
+          }
+          break;
+        }
+
+      case Stmt::IfStmtClass:
+        {
+          const IfStmt *IFS = cast<IfStmt>(S);
+          O << "if_stmt(";
+          termStmtWrapped(O, IFS->getCond());
+          O << ", ";
+          termStmtWrapped(O, IFS->getThen());
+          if (IFS->getElse()) {
+            O << ", ";
+            termStmtWrapped(O, IFS->getElse());
+          }
+          else
+            O << ", null";
+          O << ", " DAB ", ";
+          fileInfo(O, S);
+          O << ")";
+          break;
+        }
+
+      case Stmt::SwitchStmtClass:
+        {
+          const SwitchStmt *SS = cast<SwitchStmt>(S);
+
+          O << "switch_statement(";
+          termStmtWrapped(O, SS->getCond());
+          O << ", ";
+          termStmt(O, SS->getBody());
+          O << ", " DAB ", ";
+          fileInfo(O, SS);
+          O << ")";
+          break;
+        }
+
+      case Stmt::WhileStmtClass:
+        {
+          const WhileStmt *WS = cast<WhileStmt>(S);
+
+          O << "while_stmt(";
+          termStmtWrapped(O, WS->getCond());
+          O << ", ";
+          termStmtWrapped(O, WS->getBody());
+          O << ", " DAB ", ";
+          fileInfo(O, WS);
+          O << ")";
+          break;
+        }
+
+      case Stmt::DoStmtClass:
+        {
+          const DoStmt *DS = cast<DoStmt>(S);
+
+          O << "do_while_stmt(";
+          termStmtWrapped(O, DS->getBody());
+          O << ", ";
+          termStmtWrapped(O, DS->getCond());
+          O << ", " DAB ", ";
+          fileInfo(O, DS);
+          O << ")";
+          break;
+        }
+
+      case Stmt::ForStmtClass:
+        {
+          const ForStmt *FS = cast<ForStmt>(S);
+
+          O << "for_statement("
+            "for_init_statement([";
+          if(FS->getInit()) termStmtWrapped(O, FS->getInit());
+          O << "], " DAB ", "; // for_init_statement
+          fileInfo(O, FS);
+          O << "), ";
+          termStmtWrapped(O, FS->getCond());
+          O << ", ";
+          termStmt(O, FS->getInc());
+          O << ", ";
+          termStmtWrapped(O, FS->getBody());          
+          O << ", " DAB ", "; // for_stmt
+          fileInfo(O, FS);
+          O << ")";
+          break;
+        }
+
+      case Stmt::GotoStmtClass:
+        O << "goto_statement(label_annotation("
+          << quote(cast<GotoStmt>(S)->getLabel()->getName()) <<  ", ";
+        preprocessingInfo(O);        
+        O << "), " AIB ", ";
+        fileInfo(O, S);
+        O << ")";
+        break;
+
+        //       case Stmt::IndirectGotoStmtClass:
+      case Stmt::ContinueStmtClass:
+        O << "continue_stmt(" DAB ", ";
+        fileInfo(O, S);
+        O << ")";
+        break;
+
+      case Stmt::BreakStmtClass:
+        O << "break_stmt(" DAB ", ";
+        fileInfo(O, S);
+        O << ")";
+        break;
+
+      case Stmt::ReturnStmtClass:
+        {
+          const ReturnStmt *RS = cast<ReturnStmt>(S);
+          O << "return_stmt(";
+          termStmt(O, RS->getRetValue());
+          O << ", " DAB ", ";
+          fileInfo(O, S);
+          O << ")";
+          break;
+        }
+
+      case Stmt::DeclStmtClass:
+        termDeclStmt(O, S);
+        break;
+
+        // GNU Stmt Extensions
+        //       case Stmt::AsmStmtClass:
+
+        // Obj-C statements
+        //       case Stmt::ObjCAtTryStmtClass:
+        //       case Stmt::ObjCAtCatchStmtClass:
+        //       case Stmt::ObjCAtFinallyStmtClass:
+        //       case Stmt::ObjCAtThrowStmtClass:
+        //       case Stmt::ObjCAtSynchronizedStmtClass:
+        // Obj-C2 statements
+        //       case Stmt::ObjCForCollectionStmtClass:
+
+        // C++ statements
+        //       case Stmt::CXXCatchStmtClass:
+        //       case Stmt::CXXTryStmtClass:
+
+        // Expressions.
+        //       case Stmt::ExprClass:
+        //       case Stmt::PredefinedExprClass:
+        //           TermDumpExpr(Node);
+        //           switch (Node->getIdentType()) {
+        //           default: assert(0 && "unknown case");
+        //           case PredefinedExpr::Func:           fprintf(F, " __func__"); break;
+        //           case PredefinedExpr::Function:       fprintf(F, " __FUNCTION__"); break;
+        //           case PredefinedExpr::PrettyFunction: fprintf(F, " __PRETTY_FUNCTION__");break;
+        //           }
+
+      case Stmt::DeclRefExprClass:
+        termDeclRefExpr(O, S);
+        break;
+
+      case Stmt::IntegerLiteralClass:
+        {
+          const IntegerLiteral *IL = cast<IntegerLiteral>(S);
+          const BuiltinType *ILT = cast<BuiltinType>(IL->getType());
+          bool isSigned = ILT->isSignedIntegerType();
+
+          switch (ILT->getKind()) {
+          case BuiltinType::Char_U:    O << "unsigned_char"; break;
+          case BuiltinType::UChar:     O << "unsigned_char"; break;
+          case BuiltinType::UShort:    O << "unsigned_short"; break;
+          case BuiltinType::UInt:      O << "unsigned_int"; break;
+          case BuiltinType::ULong:     O << "unsigned_long"; break;
+          case BuiltinType::ULongLong: O << "unsigned_long_long"; break;
+
+          case BuiltinType::Char_S:    O << "char"; break;
+          case BuiltinType::SChar:     O << "char"; break;
+          case BuiltinType::WChar:     O << "wchar"; break;
+          case BuiltinType::Short:     O << "short"; break;
+          case BuiltinType::Int:       O << "int"; break;
+          case BuiltinType::Long:      O << "long_int"; break;
+          case BuiltinType::LongLong:  O << "long_long_int"; break;
+          default:
+            assert(false);
+          }
+
+          O << "_val(null, value_annotation("
+            << IL->getValue().toString(10, isSigned) << "," << PPI << "), " AIB ",";
+          fileInfo(O, S);
+          O << ")";
+          break;
+        }
+      case Stmt::FloatingLiteralClass:
+        {
+          const FloatingLiteral *FL = cast<FloatingLiteral>(S);
+          const BuiltinType *FLT = cast<BuiltinType>(FL->getType());
+          switch (FLT->getKind()) {
+          case BuiltinType::Float:      O << "float"; break;
+          case BuiltinType::Double:     O << "double"; break;
+          case BuiltinType::LongDouble: O << "long_double"; break;
+          default:
+            assert(false);
+          }
+          O << "_val(null, value_annotation("
+            << FL->getValueAsApproximateDouble() << ", " << PPI << "), " AIB ",";
+          fileInfo(O, S);
+          O << ")";
+          break;
+        }
+      case Stmt::StringLiteralClass:
+        {
+          const StringLiteral *SL = cast<StringLiteral>(S);
+          O << "string_val(null, value_annotation('"
+            << (SL->isWide() ? "L" : "")
+            << escape_double(std::string(SL->getStrData(), SL->getByteLength()))
+            << "', ";
+          preprocessingInfo(O);          
+          O << "), " AIB ",";
+          fileInfo(O, S);
+          O << ")";
+          break;
+        }
+      case Stmt::CharacterLiteralClass:
+        {
+          const CharacterLiteral *CL = cast<CharacterLiteral>(S);
+          O << "char_val(null, value_annotation('"
+            << escape(std::string(1, CL->getValue()))
+            << "', ";
+          preprocessingInfo(O);
+          O << "), " AIB ",",
+            fileInfo(O, S);
+          O << ")";
+          break;
+        }
+
+        //       case Stmt::ImaginaryLiteralClass: // "imag_val"
+        // 
+      case Stmt::ParenExprClass:
+        {
+          // TODO: represent in ROSE
+          const ParenExpr *PE = cast<ParenExpr>(S);
+          termStmt(O, PE->getSubExpr());
+          break;
+        }
+
+      case Stmt::UnaryOperatorClass:
+        termUnaryOperator(O, S);
+        break;
+
+      case Stmt::SizeOfAlignOfExprClass:
+        {
+          const SizeOfAlignOfExpr *SoP = cast<SizeOfAlignOfExpr>(S);
+
+          if (SoP->isSizeOf())
+            O << "size_of_op(";
+          else
+            // TODO: check if align of is available in ROSE
+            O << "align_of_op(";
+
+          if (SoP->isArgumentType())
+            O << "null";
+          else
+            termStmt(O, SoP->getArgumentExpr());
+
+          if (SoP->isSizeOf()) {
+            O << ", size_of_op_annotation(";
+            termType(O, SoP->getTypeOfArgument());
+            O << ", ";
+            termType(O, SoP->getType());
+            O << ")";
+          }
+
+          O << ", " AIB ", ";
+          fileInfo(O, SoP);
+          O << ")";
+          break;
+        }
+
+      case Stmt::ArraySubscriptExprClass:
+        {
+          const ArraySubscriptExpr *ASE = cast<ArraySubscriptExpr>(S);
+
+          O << "pntr_arr_ref_exp(";
+          termStmt(O, ASE->getBase());
+          O << ", ";
+          termStmt(O, ASE->getIdx());
+          O << ", binary_op_annotation(";
+          termType(O, ASE->getType());
+          O << ", ";
+          preprocessingInfo(O);
+          O << "), " AIB ", ";
+          fileInfo(O, ASE);
+          O << ")";
+          break;
+        }
+
+      case Stmt::CallExprClass:
+        termCallExpr(O, S);
+        break;
+
+      case Stmt::MemberExprClass:
+        {
+          const MemberExpr *ME = cast<MemberExpr>(S);
+
+          if (ME->isArrow())
+            O << "arrow_exp(";
+          else
+            O << "dot_exp(";
+
+          termStmt(O, ME->getBase());
+          O << ", ";
+          termVarRefExpr(O, ME->getMemberDecl(), ME->getType(), ME);
+          O << ", binary_op_annotation(";
+          termType(O, ME->getType());
+          O << ",";
+          preprocessingInfo(O);
+          O << "), " AIB ", ";
+          fileInfo(O, ME);
+          O << ")";
+          break;
+        }
+
+      case Stmt::ImplicitCastExprClass:
+        if (castKind == ck_undef)
+          castKind = ck_implicit;
+      case Stmt::CStyleCastExprClass:
+        if (castKind == ck_undef)
+          castKind = ck_c_style;
+      case Stmt::ExplicitCastExprClass:
+        if (castKind == ck_undef) {
+          assert(false);
+          // TODO: add support when clang is able to handle const, reinterpret
+          // and dynamic casts
+          castKind = ck_undef;
+        }
+      case Stmt::CastExprClass:
+        {
+          const CastExpr *CE = cast<CastExpr>(S);
+
+          // avoid cast on declaration references
+          if (CE->getSubExpr()->getStmtClass() == Stmt::DeclRefExprClass && 
+              CE->getType()->isPointerLikeType() ) {
+            const DeclRefExpr *DRE = cast<DeclRefExpr>(CE->getSubExpr());
+
+            if (const ValueDecl *VD = cast<ValueDecl>(DRE->getDecl())) {
+              const PointerLikeType *PT = cast<PointerLikeType>(CE->getType());
+
+              if (VD->getType() == PT->getPointeeType() ||
+                  (VD->getType()->isArrayType() &&
+                   cast<ArrayType>(VD->getType())->getElementType() ==
+                   PT->getPointeeType())) {
+                termStmt(O, CE->getSubExpr());
+                return; // exit here!!
+              }
+            }
+          }
+
+          O << "cast_exp(";
+          termStmt(O, CE->getSubExpr());
+          O << ", null, unary_op_annotation(prefix, ";
+          termType(O, CE->getType());
+          O << ",";
+          switch (castKind) {
+          case ck_implicit: O << "implicit"; break;
+          case ck_c_style: O << "c_style"; break;
+          case ck_const: O << "const"; break;
+          case ck_static: O << "static"; break;
+          case ck_dynamic: O << "dynamic"; break;
+          case ck_reinterpret: O << "reinterpret"; break;
+          case ck_undef:
+            assert(false);
+          }
+          O << ", null, ";
+          preprocessingInfo(O);          
+          O << "), " AIB ", ";
+          fileInfo(O, CE);
+          O << ")";
+          break;
+        }
+
+      case Stmt::BinaryOperatorClass:
+      case Stmt::CompoundAssignOperatorClass:
+        termBinaryOperator(O, S);
+        break;
+
+      case Stmt::ConditionalOperatorClass:
+        {
+          const ConditionalOperator *CO = cast<ConditionalOperator>(S);
+
+          O << "conditional_exp(";
+          termStmt(O, CO->getCond());
+          O << ", ";
+          termStmt(O, CO->getTrueExpr());
+          O << ", ";
+          termStmt(O, CO->getFalseExpr());
+          O << ", conditional_exp_annotation(";
+          termType(O, CO->getType());
+          O<< ",";
+          preprocessingInfo(O);          
+          O << ")"
+            ", " AIB ", ";
+          fileInfo(O, CO);
+          O << ")";
+          break;
+        }
+
+        //       case Stmt::CompoundLiteralExprClass:
+        //       case Stmt::ExtVectorElementExprClass:
+      case Stmt::InitListExprClass:
+        {
+          const InitListExpr *ILE = cast<InitListExpr>(S);
+
+          O << "expr_list_exp([";
+
+          bool first = true;
+          for(InitListExpr::const_iterator i = ILE->begin(), ie = ILE->end();
+              i != ie; i++) {
+            if (!first)
+              O << ", ";
+
+            termInitializer(O, *i);
+            first = false;
+          }
+
+          O << "], " DA ", ";
+          // TODO: file info seems to be invalid for ILE??
+          fileInfo(O, ILE);
+          O << ")";
+          break;
+        }
+
+        //       case Stmt::DesignatedInitExprClass:
+        //       case Stmt::ImplicitValueInitExprClass:
+        //       case Stmt::VAArgExprClass:
+
+        // GNU Extensions.
+        //       case Stmt::AddrLabelExprClass:
+        //         TermDumpExpr(Node);
+        //         fprintf(F, " %s %p", Node->getLabel()->getName(), (void*)Node->getLabel());
+
+        //       case Stmt::StmtExprClass:
+        //       case Stmt::TypesCompatibleExprClass:
+        //           TermDumpExpr(Node);
+        //           fprintf(F, " ");
+        //           TermDumpType(Node->getArgType1());
+        //           fprintf(F, " ");
+        //           TermDumpType(Node->getArgType2());
+
+        //       case Stmt::ChooseExprClass:
+        //       case Stmt::GNUNullExprClass:
+
+        // C++ Expressions.
+        //       case Stmt::CXXOperatorCallExprClass:
+        //       case Stmt::CXXMemberCallExprClass:
+        //       case Stmt::CXXNamedCastExprClass:
+        //       case Stmt::CXXStaticCastExprClass:
+        //       case Stmt::CXXDynamicCastExprClass:
+        //       case Stmt::CXXReinterpretCastExprClass:
+        //       case Stmt::CXXConstCastExprClass:
+        //       case Stmt::CXXFunctionalCastExprClass:
+        //       case Stmt::CXXTemporaryObjectExprClass:
+        //       case Stmt::CXXTypeidExprClass:
+        //       case Stmt::CXXBoolLiteralExprClass:
+        //       case Stmt::CXXThisExprClass:
+        //       case Stmt::CXXThrowExprClass:
+        //       case Stmt::CXXDefaultArgExprClass:
+        //       case Stmt::CXXZeroInitValueExprClass:
+        //       case Stmt::CXXConditionDeclExprClass:
+        //       case Stmt::CXXNewExprClass:
+        //       case Stmt::CXXDeleteExprClass:
+        //       case Stmt::CXXDependentNameExprClass:
+        //       case Stmt::UnaryTypeTraitExprClass:
+        //       case Stmt::QualifiedDeclRefExprClass:
+
+        // Obj-C Expressions.
+        //       case Stmt::ObjCStringLiteralClass:
+        //       case Stmt::ObjCEncodeExprClass:
+        //       case Stmt::ObjCMessageExprClass:
+        //       case Stmt::ObjCSelectorExprClass:
+        //       case Stmt::ObjCProtocolExprClass:
+        //       case Stmt::ObjCIvarRefExprClass:
+        //       case Stmt::ObjCPropertyRefExprClass:
+        //       case Stmt::ObjCKVCRefExprClass:
+        //       case Stmt::ObjCSuperExprClass:
+
+        // Clang Extensions.
+        //       case Stmt::OverloadExprClass:
+        //       case Stmt::ShuffleVectorExprClass:
+        //       case Stmt::BlockExprClass:
+        //       case Stmt::BlockDeclRefExprClass:
+      default:
+        O << "some_expression(" << S->getStmtClassName() << ")";
+      }
+    }
+    
+    // NOTE: Controll does not allways reach this point here for all statements
+    // and expressions.
+  }
+
+  void ASTTermDumper::termStmtWrapped(std::ostream &O, const Stmt *S) {
+    if (!S || dyn_cast<Expr>(S))
+      O << "expr_statement(";
+    
+    termStmt(O, S);
+    
+    if (!S || dyn_cast<Expr>(S)) {
+      O << ", " DAB ", ";
+      fileInfo(O, S);
+      O << ")";      
+    }
+  }
+
+  void ASTTermDumper::termUnaryOperator(std::ostream &O, const Stmt *S) {
+    const UnaryOperator* UO = cast<UnaryOperator>(S);
+
+    switch (UO->getOpcode()) {
+    case UnaryOperator::PostInc:   O << "plus_plus_op";      break;
+    case UnaryOperator::PostDec:   O << "minus_minus_op";    break;
+    case UnaryOperator::PreInc:    O << "plus_plus_op";      break;
+    case UnaryOperator::PreDec:    O << "minus_minus_op";    break;
+    case UnaryOperator::AddrOf:    O << "address_of_op";     break;
+    case UnaryOperator::Deref:     O << "pointer_deref_exp"; break;
+    case UnaryOperator::Plus:      O << "plus_op";           break;
+    case UnaryOperator::Minus:     O << "minus_op";          break;
+    case UnaryOperator::Not:       O << "bit_complement_op"; break;
+    case UnaryOperator::LNot:      O << "not_op";            break;
+    case UnaryOperator::Real:      O << "real_op";           break;
+    case UnaryOperator::Imag:      O << "imag_op";           break;
+    case UnaryOperator::Extension: O << "extension_op";      break;
+    case UnaryOperator::OffsetOf:  O << "offset_op";         break;
+    }
+
+    O << "(";
+    termStmt(O, UO->getSubExpr());
+    O << ", unary_op_annotation("
+      << (UO->isPostfix() ? "postfix, " : "prefix, ");
+    termType(O, UO->getType());
+    O << ", null, null,";
+    preprocessingInfo(O);
+    O<< "), " AIB ", ";
+    fileInfo(O, S);
+    O << ")";
+  }
+
+  void ASTTermDumper::termBinaryOperator(std::ostream &O, const Stmt *S) {
+    const BinaryOperator* BO = cast<BinaryOperator>(S);
+
+    switch (BO->getOpcode()) {
+    case BinaryOperator::Mul:       O <<         "multiply_op"; break;
+    case BinaryOperator::Div:       O <<           "divide_op"; break;
+    case BinaryOperator::Rem:       O <<              "mod_op"; break;
+    case BinaryOperator::Add:       O <<               "add_op"; break;
+    case BinaryOperator::Sub:       O <<          "subtract_op"; break;
+    case BinaryOperator::Shl:       O <<            "lshift_op"; break;
+    case BinaryOperator::Shr:       O <<            "rshift_op"; break;
+    case BinaryOperator::LT:        O <<        "less_than_op"; break;
+    case BinaryOperator::GT:        O <<     "greater_than_op"; break;
+    case BinaryOperator::LE:        O <<    "less_or_equal_op"; break;
+    case BinaryOperator::GE:        O << "greater_or_equal_op"; break;
+    case BinaryOperator::EQ:        O <<         "equality_op"; break;
+    case BinaryOperator::NE:        O <<        "not_equal_op"; break;
+    case BinaryOperator::And:       O <<          "bit_and_op"; break;
+    case BinaryOperator::Xor:       O <<          "bit_xor_op"; break;
+    case BinaryOperator::Or:        O <<           "bit_or_op"; break;
+    case BinaryOperator::LAnd:      O <<              "and_op"; break;
+    case BinaryOperator::LOr:       O <<               "or_op"; break;
+    case BinaryOperator::Assign:    O <<           "assign_op"; break;
+    case BinaryOperator::MulAssign: O <<      "mult_assign_op"; break;
+    case BinaryOperator::DivAssign: O <<       "div_assign_op"; break;
+    case BinaryOperator::RemAssign: O <<       "mod_assign_op"; break;
+    case BinaryOperator::AddAssign: O <<       "plus_assign_op"; break;
+    case BinaryOperator::SubAssign: O <<     "minus_assign_op"; break;
+    case BinaryOperator::ShlAssign: O <<     "lshift_assign_op"; break;
+    case BinaryOperator::ShrAssign: O <<     "rshift_assign_op"; break;
+    case BinaryOperator::AndAssign: O <<        "and_assign_op"; break;
+    case BinaryOperator::XorAssign: O <<        "xor_assign_op"; break;
+    case BinaryOperator::OrAssign:  O <<        "ior_assign_op"; break;
+    case BinaryOperator::Comma:     O <<         "comma_op_exp"; break;
+    }
+    O << "(";
+    termStmt(O, BO->getLHS());
+    O << ", ";
+    termStmt(O, BO->getRHS());
+    O << ", binary_op_annotation(";
+    termType(O, BO->getType());
+    O << ",";
+    preprocessingInfo(O);    
+    O << "), " AIB ", ";
+    fileInfo(O, BO);
+    O << ")";
+  }
+
+  void ASTTermDumper::termDeclStmt(std::ostream &O, const Stmt *S) {
+    const DeclStmt *DS = cast<DeclStmt>(S);
+
+    bool first = true;
+    for(DeclStmt::const_decl_iterator d = DS->decl_begin(),
+          de = DS->decl_end(); d != de; ++d) {
+      if (!first)
+        O << ", ";
+
+      termDecl(O, *d);
+      first = false;
+    }
+  }
+
+  void ASTTermDumper::termCallExpr(std::ostream &O, const Stmt *S) {
+    const CallExpr *CE = cast<CallExpr>(S);
+
+    O << "function_call_exp(";
+    termStmt(O,CE->getCallee());
+    O << ", expr_list_exp([";
+
+    bool first = true;
+    for(CallExpr::const_arg_iterator i = CE->arg_begin(), ie = CE->arg_end();
+        i != ie; ++i) {
+      if (!first)
+        O << ", ";
+
+      termStmt(O, *i);
+      first = false;
+    }
+    O << "], " DA ", ";
+    fileInfo(O, S);
+    O << "), function_call_exp_annotation(";
+    termType(O, CE->getType());
+    O <<", ";
+    preprocessingInfo(O);
+    O << "), " AIB ", ";
+    fileInfo(O, S);
+    O << ")";
+  }
+
+  void ASTTermDumper::termDeclRefExpr(std::ostream &O, const Stmt *S) {
+    const DeclRefExpr *DRE = cast<DeclRefExpr>(S);
+    const Decl *D = DRE->getDecl();
+
+    std::string ref_type("");
+    switch (D->getKind()) {
+    case Decl::Function:
+      O << "function_ref_exp("
+        << "function_ref_exp_annotation("
+        << declIdentifier(D)
+        << ", ";
+      termType(O, cast<FunctionDecl>(D)->getType());
+      O << ",";
+      preprocessingInfo(O);
+      O << "), " AIB ", ";
+      fileInfo(O, S);
+      O << ")";      
+      break;
+      
+    case Decl::Var:
+    case Decl::OriginalParmVar:
+    case Decl::ImplicitParam:
+    case Decl::ParmVar:
+      termVarRefExpr(O, D, DRE->getType(), DRE);
+      break;
+    case Decl::EnumConstant:
+      {
+        const EnumConstantDecl *ED = cast<EnumConstantDecl>(D);
+        const llvm::APSInt &val = ED->getInitVal();
+        O << "int_val(null, value_annotation(" << val.toString(10) << ", " << PPI << "), " AIB ",";
+        fileInfo(O, S);
+        O << ")";
+        break;
+      }
+    default:
+      assert(false && "Cannot handle declaration in DeclRefExpr.\n");
+    }
+  }
+
+  void ASTTermDumper::termVarRefExpr(std::ostream &O, const Decl *D,
+                                     const QualType &T,
+                                     const Stmt *SL) {
+    O << "var_ref_exp("
+      "var_ref_exp_annotation(";
+    termType(O, T);
+    O << ", "
+      << declIdentifier(D)
+      << ", ";
+    termStaticStorage(O, D);
+    O << ", ";
+    termDeclContext(O, D->getDeclContext());
+    O << ", ";
+    preprocessingInfo(O);    
+    O << "), " AIB ", ";
+    fileInfo(O, SL);
+    O << ")";
+  }
+
+  /***************************************************************************
+   * Misc                                                                    *
+   **************************************************************************/
+  std::string ASTTermDumper::declIdentifier(const Decl *D, const char* prefix /*=""*/) {
+    const NamedDecl *V;
+    const IdentifierInfo *I;    
+    assert(D && "identifier information expected");
+    std::string s(prefix);
+
+    if((V = cast<NamedDecl>(D)) != NULL && (I = V->getIdentifier()) != NULL){
+      s += I->getName();
+    }
+    else {
+      std::ostringstream O;
+      std::string kind(D->getDeclKindName());
+      std::transform(kind.begin(), kind.end(), kind.begin(), tolower);      
+      O << "__anonymous_" << kind << "_decl";
+
+      //do we have source information?
+      const SourceLocation Loc = D->getLocation();
+      SourceLocation SpellingLoc = SM->getSpellingLoc(Loc);
+      if(!SpellingLoc.isInvalid()) {
+        PresumedLoc PLoc = SM->getPresumedLoc(SpellingLoc);
+        std::string file(std::string("/") +  PLoc.getFilename());
+        file = file.substr(file.rfind("/") + 1);
+        std::transform(file.begin(), file.end(), file.begin(), tolower);
+        O << "_" << filter_string(file) << "_" << PLoc.getLine() << "_" << PLoc.getColumn();
+      }
+      O << "_" << D;
+      s+= O.str();
+    }
+    return quote(s);
+  }
+  
+  void ASTTermDumper::termInitializedName(std::ostream &O, const Decl *D) {
+    const NamedDecl *V = cast<NamedDecl>(D);
+
+    const Expr* init = NULL;
+    QualType type(getQualType(V));
+    if (VarDecl::classof(V)) {
+      const VarDecl *VD = cast<VarDecl>(V);
+      init = VD->getInit();
+    }
+    else if (EnumConstantDecl::classof(V)) {
+      const EnumConstantDecl *ED = cast<EnumConstantDecl>(V);
+      init = ED->getInitExpr();
+    }
+
+    // If this is a vardecl with an initializer, emit it.
+    O << "initialized_name(";
+    if (init) {
+      termInitializer(O , init);
+    }
+    else
+      O << "null";
+
+    O << ", initialized_name_annotation(";
+    if (type.isNull())
+      O << "null";
+    else
+      termType(O, type);
+
+    O << ", " << declIdentifier(D) << ", ";
+    termStaticStorage(O, V);
+    O << ", ";
+    termDeclContext(O, V->getDeclContext());
+    O << "), " AIB ", ";
+    fileInfo(O, D);
+    O << ")";
+  }
+
+  void ASTTermDumper::termInitializer(std::ostream &O, const Stmt *S) {
+    const Expr *E = dyn_cast<Expr>(S);
+
+    bool is_aggregate = E && (E->getType()->isRecordType() ||
+                              E->getType()->isArrayType());
+
+    if (is_aggregate)
+      O << "aggregate_initializer(";
+    else
+      O << "assign_initializer(";
+
+    termStmt(O, S);
+
+    if (!is_aggregate) {
+      O << ", assign_initializer_annotation(";
+      if (E)
+        termType(O, E->getType());
+      else
+        O << "null";
+
+      O << ", ";
+      preprocessingInfo(O);
+      
+      O << "), " AIB ", ";
+    }
+    else {
+      O << ", " DA ", ";
+    }
+    fileInfo(O, S);
+    O << ")";
+  }
+
+  void ASTTermDumper::termStaticStorage(std::ostream &O, const Decl *D) {
+    const VarDecl *V = dyn_cast<VarDecl>(D);
+    const FunctionDecl *F = dyn_cast<FunctionDecl>(D);
+    bool isStatic = (V && V->getStorageClass() == VarDecl::Static) ||
+      (F && F->getStorageClass() == FunctionDecl::Static);
+
+    O << (isStatic ? "static" : "default");
+  }
+
+
+  void ASTTermDumper::termAccessModifier(std::ostream &O, const Decl *D) {
+    switch (D->getAccess()) {
+    case AS_none:      O << "default"; break;
+    case AS_public:    O << "public"; break;
+    case AS_protected: O << "protected"; break;
+    case AS_private:   O << "private"; break;
+    }
+  }
+
+  void ASTTermDumper::termStorageModifier(std::ostream &O, const Decl *D) {
+    // Translate Storage classes
+    if (const VarDecl *V = dyn_cast<VarDecl>(D)) {
+      switch (V->getStorageClass()) {
+      case VarDecl::None:     O << "default"; break;
+      case VarDecl::Extern:   O << "extern"; break;
+      case VarDecl::Static:   O << "static"; break;
+      case VarDecl::Auto:     O << "auto"; break;
+      case VarDecl::Register: O << "register"; break;
+      case VarDecl::PrivateExtern:   O << "privateExtern"; break;
+        // TODO: will never be used for clang?
+        //unparse_storage_modifier(7) :- !, write('mutable ').
+        //unparse_storage_modifier(8) :- !, write('typedef ').
+        //unparse_storage_modifier(9) :- !, write('asm ').
+      }
+    }
+    else if (const FunctionDecl *F = dyn_cast<FunctionDecl>(D)) {
+      switch (F->getStorageClass()) {
+      case FunctionDecl::None:     O << "default"; break;
+      case FunctionDecl::Extern:   O << "extern"; break;
+      case FunctionDecl::Static:   O << "static"; break;
+      case FunctionDecl::PrivateExtern:   O << "privateExtern"; break;
+        // TODO: will never be used for clang?
+        //unparse_storage_modifier(7) :- !, write('mutable ').
+        //unparse_storage_modifier(8) :- !, write('typedef ').
+        //unparse_storage_modifier(9) :- !, write('asm ').
+      }
+    }
+    else if (dyn_cast<FieldDecl>(D)) {
+      O << "default";
+    }
+    else
+      assert(0 && "Unknown decl type!");
+  }
+
+  void ASTTermDumper::termModifier(std::ostream &O, const Decl *D) {
+    // TODO: dump real values here - text version prefered
+    O << "declaration_modifier("
+      // TODO: find these modifiers in clang.
+      // e_unknown    Unknown value (error)
+      // e_default    Default value
+      // e_friend    Friend qualifier
+      // e_typedef    Typedef qualifier (not clear if this is used, I don't think typedef is a modifier)
+      // e_export    Export qualifier
+      // e_throw    Exception handling support (throw)
+      // e_bind    Fortran bind attribute for declarations (functions, variable, and classes)
+      // e_final    PHP support for specification to not be extended (should be useful for Java, if required in the future)
+      "[default],";
+    termTypeModifier(O, D);
+    O << ", ";
+    termAccessModifier(O, D);
+    O << ", ";
+    termStorageModifier(O, D);
+    O << ")";
+  }
+
+  void ASTTermDumper::termTypeModifier(std::ostream &O, const Decl *D) {
+    QualType type(getQualType(D));
+    assert(!type.isNull());
+
+    O << "type_modifier(";
+
+    // -------------------------
+    AtomSetStream Q(O);
+    Q << "default";
+
+    if (type.isRestrictQualified())
+      Q << "restrict";
+
+    // TODO: fortran specific
+    //     // Fortran specific modifiers (in Fortran these are called attribute specifiers)
+    //     // Note that public and private access attributes are mapped to the C/C++ access modifiers in SgDeclarationModifier
+    //     "public_access",  // = 3, /*!< public qualifier (for Fortran 90) */
+    //     "private_access", // = 4, /*!< private qualifier (for Fortran 90) */
+    //     "allocatable",    // = 3, /*!< allocatable attribute specifier (for Fortran 90) */
+    //     "asynchronous",   // = 4, /*!< asynchronous attribute specifier (for Fortran 2003) */
+    //     "bind", // = 5, /*!< bind attribute specifier (for Fortran 2003, this is closely related to the SgLinkageModifier) */
+    //     "data", // = 6, /*!< data attribute specifier (for Fortran 77) */
+    //     "dimension", // = 7, /*!< dimension attribute specifier (for Fortran 77) */
+    //     // This should map to the C/C++ extern modifier in SgStorageModifier
+    //     //"external       ", // = x, /*!< external attribute specifier (for Fortran 77, this is less related to the SgLinkageModifier than the SgStorageModifier) */
+    //     "intent_in",    // = 8, /*!< intent(in) attribute specifier (for Fortran 90) */
+    //     "intent_out",   // = 9, /*!< intent(out) attribute specifier (for Fortran 90) */
+    //     "intent_inout", // = 10,/*!< intent(inout) attribute specifier (for Fortran 90) */
+    //     "intrinsic",    // = 11,/*!< intrinsic attribute specifier (for Fortran 90) */
+    //     "optional",     // = 12,/*!< optional attribute specifier (for Fortran 90) */
+    //     // This should map to const in the SgConstVolatileModifier
+    //     //"parameter      ", // = xx,/*!< parameter attribute specifier (for Fortran 77) */
+    // 
+    //     // This should be mapped to the SgPointerType in C/C++
+    //     //"pointer        ", // = xx,/*!< pointer attribute specifier (for Fortran 90) */
+    //     // Note that protected access attribute is mapped to the C/C++ protected access modifiers in SgDeclarationModifier
+    //     //"protected      ", // = xx,/*!< protected attribute specifier (for Fortran 2003) */
+    //     "save",   // = 13,/*!< save attribute specifier (for Fortran 77) */
+    //     "target", // = 14,/*!< target attribute specifier (for Fortran 90) */
+    //     "value",  // = 15,/*!< value attribute specifier (for Fortran 2003) */
+    //     // This should map to volatile in the SgConstVolatileModifier
+    //     //"volatile       ", // = xx,/*!< volatile attribute specifier (for Fortran 2003) */
+
+    // DQ (12/4/2007): Added support for GNU specific attributes
+    if (D->getAttr<UnusedAttr>())
+      Q << "gnu_attribute__unused__";
+
+    if (D->getAttr<PackedAttr>())
+      Q << "gnu_attribute__packed__";
+
+    if (D->getAttr<DeprecatedAttr>())
+      Q << "gnu_attribute__deprecated__";
+
+    if (D->getAttr<TransparentUnionAttr>())
+      Q << "gnu_attribute__transparent_union__";
+
+    if (D->getAttr<NoReturnAttr>())
+      Q << "gnu_attribute__noreturn__";
+
+    if (D->getAttr<ConstAttr>())
+      Q << "gnu_attribute__const__";
+
+    if (D->getAttr<PackedAttr>())
+      Q << "gnu_attribute__cdecl__";
+
+    if (D->getAttr<StdCallAttr>())
+      Q << "gnu_attribute__stdcall__";
+
+    // TODO: lots of other attributes in clang available
+
+    Q.close();
+
+    // -------------------------
+    // TODO: find equivalent in clang
+    //  e_default    default value
+    //  e_upc_strict    UPC strict
+    //  e_upc_relaxed    UPC relaxed
+    //  e_last_modifier    last value (upper bound on range of values, used in error checking)
+    O << ", default, ";
+
+    // -------------------------
+    if (type.isConstQualified())
+      O << "const, ";
+    else if (type.isVolatileQualified())
+      O << "volatile, ";
+    else
+      O << "default, ";
+
+    // -------------------------
+    if (type->isClassType())
+      O << "class";
+    else if (type->isStructureType())
+      O << "struct";
+    else if (type->isUnionType())
+      O << "union";
+    else if (type->isEnumeralType())
+      O << "enum";
+    else if (type->isTemplateTypeParmType())
+      O << "typename";
+    else
+      O << "default";
+
+    O << ")";
+  }
+
+  void ASTTermDumper::termTypeModifier(std::ostream &O, const QualType T) {
+    O << "type_modifier(";
+
+    // -------------------------
+    AtomSetStream Q(O);
+    Q << "default";
+    
+    if (T.isRestrictQualified())
+      Q << "restrict";
+
+    // TODO: fortran specific
+    //     // Fortran specific modifiers (in Fortran these are called attribute specifiers)
+    //     // Note that public and private access attributes are mapped to the C/C++ access modifiers in SgDeclarationModifier
+    //     "public_access",  // = 3, /*!< public qualifier (for Fortran 90) */
+    //     "private_access", // = 4, /*!< private qualifier (for Fortran 90) */
+    //     "allocatable",    // = 3, /*!< allocatable attribute specifier (for Fortran 90) */
+    //     "asynchronous",   // = 4, /*!< asynchronous attribute specifier (for Fortran 2003) */
+    //     "bind", // = 5, /*!< bind attribute specifier (for Fortran 2003, this is closely related to the SgLinkageModifier) */
+    //     "data", // = 6, /*!< data attribute specifier (for Fortran 77) */
+    //     "dimension", // = 7, /*!< dimension attribute specifier (for Fortran 77) */
+    //     // This should map to the C/C++ extern modifier in SgStorageModifier
+    //     //"external       ", // = x, /*!< external attribute specifier (for Fortran 77, this is less related to the SgLinkageModifier than the SgStorageModifier) */
+    //     "intent_in",    // = 8, /*!< intent(in) attribute specifier (for Fortran 90) */
+    //     "intent_out",   // = 9, /*!< intent(out) attribute specifier (for Fortran 90) */
+    //     "intent_inout", // = 10,/*!< intent(inout) attribute specifier (for Fortran 90) */
+    //     "intrinsic",    // = 11,/*!< intrinsic attribute specifier (for Fortran 90) */
+    //     "optional",     // = 12,/*!< optional attribute specifier (for Fortran 90) */
+    //     // This should map to const in the SgConstVolatileModifier
+    //     //"parameter      ", // = xx,/*!< parameter attribute specifier (for Fortran 77) */
+    // 
+    //     // This should be mapped to the SgPointerType in C/C++
+    //     //"pointer        ", // = xx,/*!< pointer attribute specifier (for Fortran 90) */
+    //     // Note that protected access attribute is mapped to the C/C++ protected access modifiers in SgDeclarationModifier
+    //     //"protected      ", // = xx,/*!< protected attribute specifier (for Fortran 2003) */
+    //     "save",   // = 13,/*!< save attribute specifier (for Fortran 77) */
+    //     "target", // = 14,/*!< target attribute specifier (for Fortran 90) */
+    //     "value",  // = 15,/*!< value attribute specifier (for Fortran 2003) */
+    //     // This should map to volatile in the SgConstVolatileModifier
+    //     //"volatile       ", // = xx,/*!< volatile attribute specifier (for Fortran 2003) */
+
+    Q.close();
+
+    // -------------------------
+    // TODO: find equivalent in clang
+    //  e_default    default value
+    //  e_upc_strict    UPC strict
+    //  e_upc_relaxed    UPC relaxed
+    //  e_last_modifier    last value (upper bound on range of values, used in error checking)
+    O << ", default, ";
+
+    // -------------------------
+    if (T.isConstQualified())
+      O << "const, ";
+    else if (T.isVolatileQualified())
+      O << "volatile, ";
+    else
+      O << "default, ";
+
+    // -------------------------
+    if (T->isClassType())
+      O << "class";
+    else if (T->isStructureType())
+      O << "struct";
+    else if (T->isUnionType())
+      O << "union";
+    else if (T->isEnumeralType())
+      O << "enum";
+    else if (T->isTemplateTypeParmType())
+      O << "typename";
+    else
+      O << "default";
+
+    O << ")";
+  }
+
+  void ASTTermDumper::termDeclAttributes(std::ostream &O, const Decl *D) {
+    // TODO: real values here
+    O << "decl_attributes(0, 0, 0, 0, 0)";
+  }
+
+  void ASTTermDumper::termDeclContext(std::ostream &O, const DeclContext *C) {
+    switch (C->getDeclKind()) {
+    case Decl::Namespace:
+      O << declIdentifier(cast<NamespaceDecl>(C));
+      break;
+    case Decl::Record:
+      if (const RecordDecl *RD = dyn_cast<RecordDecl>(C)) {
+        if(RD->getKind() == Decl::Enum && !RD->getIdentifier()) {
+          //mimic the bahaviour of the ROSE implementation here
+          O << "::";
+        }
+        else {
+          O << "class_scope("
+            << declIdentifier(RD, "::")
+            << ", " << RD->getKindName() << ")";          
+        }
+        break;
+      }
+    default:
+      O << "null";
+    }
+  }
+}
+
+ASTConsumer *clang::CreateASTTermDumper(const std::string &infile,
+                                        const std::string &outfile,
+                                        Preprocessor *PP) {
+  
+  return new ASTTermDumper(infile, outfile, PP);
+}
+
Index: Driver/ASTConsumers.h
===================================================================
--- Driver/ASTConsumers.h	(revision 63505)
+++ Driver/ASTConsumers.h	(working copy)
@@ -36,6 +36,10 @@
 
 ASTConsumer *CreateASTDumper();
 
+ASTConsumer *CreateASTTermDumper(const std::string &infile,
+                                 const std::string &outfile,
+                                 Preprocessor *PP);
+
 ASTConsumer *CreateASTViewer();
 
 ASTConsumer *CreateDeclContextPrinter();
Index: tools/ccc/ccclib/HostInfo.py
===================================================================
--- tools/ccc/ccclib/HostInfo.py	(revision 63505)
+++ tools/ccc/ccclib/HostInfo.py	(working copy)
@@ -89,6 +89,45 @@
             
     raise RuntimeError,'Unrecognized Darwin platform: %r:%r' % (machine, bits)
 
+# Linux
+
+class LinuxHostInfo(HostInfo):
+    def __init__(self, driver):
+        super(LinuxHostInfo, self).__init__(driver)
+        self.gccVersion = (4,2,1)
+
+    def useDriverDriver(self):
+        return False
+
+    def getToolChain(self):
+        return self.getToolChainForArch(self.getArchName(None))
+
+    def getToolChainForArch(self, arch):
+        return ToolChain.Generic_GCC_ToolChain(self.driver)
+
+class LinuxX86HostInfo(LinuxHostInfo):
+    def getArchName(self, args):
+        if args and args.getLastArg(args.parser.m_64Option):
+            return 'x86_64'
+        return 'i386'
+
+class LinuxX86_64HostInfo(LinuxHostInfo):
+    def getArchName(self, args):
+        if args and args.getLastArg(args.parser.m_32Option):
+            return 'i386'
+        return 'x86_64'
+
+def getLinuxHostInfo(driver):
+    machine = driver.getHostMachine()
+    bits = driver.getHostBits()
+    if machine == 'i386':
+        if bits == '32':
+            return LinuxX86HostInfo(driver)
+        if bits == '64':
+            return LinuxX86_64HostInfo(driver)
+
+    raise RuntimeError,'Unrecognized Linux platform: %r:%r' % (machine, bits)
+
 # Unknown
 
 class UnknownHostInfo(HostInfo):
@@ -107,7 +146,8 @@
 ####
 
 kSystems = {
-    'darwin' : getDarwinHostInfo,
+    'darwin'  : getDarwinHostInfo,
+    'linux'   : getLinuxHostInfo,
     'unknown' : getUnknownHostInfo,
     }
 
Index: tools/ccc/ccclib/Tools.py
===================================================================
--- tools/ccc/ccclib/Tools.py	(revision 63505)
+++ tools/ccc/ccclib/Tools.py	(working copy)
@@ -178,6 +178,12 @@
 
         patchOutputNameForPTH = False
 
+        cmd_args.append('-arch')
+        if arch:
+            cmd_args.append(arch)
+        else:
+            cmd_args.append(self.toolChain.driver.hostInfo.getArchName(arglist))
+
         if isinstance(phase.phase, Phases.AnalyzePhase):
             assert outputType is Types.PlistType
             cmd_args.append('-analyze')
Index: lib/Lex/PPDirectives.cpp
===================================================================
--- lib/Lex/PPDirectives.cpp	(revision 63505)
+++ lib/Lex/PPDirectives.cpp	(working copy)
@@ -18,6 +18,7 @@
 #include "clang/Lex/LexDiagnostic.h"
 #include "clang/Basic/SourceManager.h"
 #include "llvm/ADT/APInt.h"
+#include <iostream>
 using namespace clang;
 
 //===----------------------------------------------------------------------===//
@@ -959,6 +960,9 @@
     DiscardUntilEndOfDirective();
     return;
   }
+
+  if (Callbacks)
+    Callbacks->IncludeDirective(FilenameTok.getLocation(), std::string(FilenameStart, FilenameEnd));
   
   bool isAngled = GetIncludeFilenameSpelling(FilenameTok.getLocation(),
                                              FilenameStart, FilenameEnd);
