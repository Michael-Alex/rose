%{ /* -*- C++ -*-
   Copyright 2008 Adrian Prantl
   see LICENSE in the root folder of this project
*/
using namespace std;
#include <iostream>  
#include <deque>
#include <string>
#include "PrologTerm.h"
#include "PrologCompTerm.h"
#include "PrologList.h"
#include "PrologAtom.h"
#include "PrologString.h"
#include "PrologInt.h"
#include "PrologVariable.h"

extern int   dfilex();
extern char* dfitext;
extern int   dfilineno;
PrologCompTerm*  dfiterm;
const char* dfi_name;

void dfierror(char *);

%}

/*Token declarations*/
%token <strValue> TOKEN
%token <strValue> TOP 
%token <strValue> BOTTOM
%token <strValue> ASSIGN
%token <intValue> INT 

/*data structure*/
%union {
  int intValue;
  std::string* strValue;
  PrologTerm* singleTerm;
  std::deque<PrologTerm*>* termList;
}

/*nonterminal types*/
%type <singleTerm> result
%type <singleTerm> value
%type <singleTerm> indicator
%type <singleTerm> assignment
%type <termList>   ints
%type <termList>   assignments

%%

/*grammar*/

result:
  '[' indicator ':' ']' { 
    dfiterm = new PrologCompTerm(dfi_name);
    dfiterm->addSubterm($2); 
    dfiterm->addSubterm(new PrologList());
    //cerr << dfiterm->getRepresentation() << endl;
  }
  | '[' indicator ':' assignments ']' { 
    dfiterm = new PrologCompTerm(dfi_name);
    dfiterm->addSubterm($2); 
    dfiterm->addSubterm(new PrologList(*$4));
    //cerr << dfiterm->getRepresentation() << endl;
  }
;

assignments:
  assignment ','  { $$ = new deque<PrologTerm*>(); $$->push_front($1); }
  | assignment ',' assignments { $3->push_front($1); $$=$3; }
;

assignment:
  TOKEN ASSIGN value { 
    PrologInfixOperator* ifx = new PrologInfixOperator("->");
    ifx->addSubterm(new PrologAtom(*$1));
    ifx->addSubterm($3);
    $$ = ifx;
  }
;

indicator: 
  TOP      { $$ = new PrologAtom("top"); }
  | BOTTOM { $$ = new PrologAtom("bottom"); }
;

value:
  INT            { $$ = new PrologInt($1);      }
  | '(' ints ')' { $$ = new PrologList(*$2);     }
;

ints:
  INT            { $$ = new deque<PrologTerm*>(); $$->push_front(new PrologInt($1));      }
  | INT ',' ints { $3->push_front(new PrologInt($1)); $$=$3; }
;

%%

extern const char* dfi_input;

void dfierror(char* msg) 
{
  cerr << std::string(msg) 
       << " near token '" << dfitext << "'" 
       << " before " << dfi_input << endl;
  dfiterm = new PrologCompTerm(dfi_name);
  dfiterm->addSubterm(new PrologAtom("parse error"));
  dfiterm->addSubterm(new PrologAtom(dfitext));
}


